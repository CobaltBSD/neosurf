<?xml version="1.0"?>
<!--
Copyright (c) 2001-2003 World Wide Web Consortium,
(Massachusetts Institute of Technology, Institut National de
Recherche en Informatique et en Automatique, Keio University). All
Rights Reserved. This program is distributed under the W3C's Document
Intellectual Property License. This program is distributed in the
hope that it will be useful, but WITHOUT ANY WARRANTY; without even
the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.
See W3C License http://www.w3.org/Consortium/Legal/ for more details.
-->
<!--This file is an extract of interface definitions from Document Object Model (DOM) Level 3 Core Specification-->
<library>
  <exception name="DOMException" id="ID-17189187"><descr><p>DOM operations only raise exceptions in "exceptional" circumstances, i.e., when an operation is impossible to perform (either for logical reasons, because data is lost, or because the implementation has become unstable). In general, DOM methods return specific error values in ordinary processing situations, such as out-of-bound errors when using<code>NodeList</code>.</p><p>Implementations should raise other exceptions under other circumstances. For example, implementations should raise an implementation-dependent exception if a<code>null</code>argument is passed when<code>null</code>was not expected.</p><p>Some languages and object systems do not support the concept of exceptions. For such systems, error conditions may be indicated using native error reporting mechanisms. For some bindings, for example, methods may return error codes similar to those listed in the corresponding method descriptions.</p></descr><component id="ID-146F692A" name="code"><typename>unsigned short</typename></component></exception>
  <group id="ID-258A00AF" name="ExceptionCode"><descr><p>An integer indicating the type of error generated.</p><note><p>Other numeric codes are reserved for W3C for possible future use.</p></note></descr><constant id="DOMException-INDEX_SIZE_ERR" name="INDEX_SIZE_ERR" type="unsigned short" value="1"><descr><p>If index or size is negative, or greater than the allowed value.</p></descr></constant><constant id="DOMException-DOMSTRING_SIZE_ERR" name="DOMSTRING_SIZE_ERR" type="unsigned short" value="2"><descr><p>If the specified range of text does not fit into a<code>DOMString</code>.</p></descr></constant><constant id="DOMException-HIERARCHY_REQUEST_ERR" name="HIERARCHY_REQUEST_ERR" type="unsigned short" value="3"><descr><p>If any<code>Node</code>is inserted somewhere it doesn't belong.</p></descr></constant><constant id="DOMException-WRONG_DOCUMENT_ERR" name="WRONG_DOCUMENT_ERR" type="unsigned short" value="4"><descr><p>If a<code>Node</code>is used in a different document than the one that created it (that doesn't support it).</p></descr></constant><constant id="DOMException-INVALID_CHARACTER_ERR" name="INVALID_CHARACTER_ERR" type="unsigned short" value="5"><descr><p>If an invalid or illegal character is specified, such as in an XML name.</p></descr></constant><constant id="DOMException-NO_DATA_ALLOWED_ERR" name="NO_DATA_ALLOWED_ERR" type="unsigned short" value="6"><descr><p>If data is specified for a<code>Node</code>which does not support data.</p></descr></constant><constant id="DOMException-NO_MODIFICATION_ALLOWED_ERR" name="NO_MODIFICATION_ALLOWED_ERR" type="unsigned short" value="7"><descr><p>If an attempt is made to modify an object where modifications are not allowed.</p></descr></constant><constant id="DOMException-NOT_FOUND_ERR" name="NOT_FOUND_ERR" type="unsigned short" value="8"><descr><p>If an attempt is made to reference a<code>Node</code>in a context where it does not exist.</p></descr></constant><constant id="DOMException-NOT_SUPPORTED_ERR" name="NOT_SUPPORTED_ERR" type="unsigned short" value="9"><descr><p>If the implementation does not support the requested type of object or operation.</p></descr></constant><constant id="DOMException-INUSE_ATTRIBUTE_ERR" name="INUSE_ATTRIBUTE_ERR" type="unsigned short" value="10"><descr><p>If an attempt is made to add an attribute that is already in use elsewhere.</p></descr></constant><constant id="DOMException-INVALID_STATE_ERR" name="INVALID_STATE_ERR" type="unsigned short" value="11" since="DOM Level 2"><descr><p>If an attempt is made to use an object that is not, or is no longer, usable.</p></descr></constant><constant id="DOMException-SYNTAX_ERR" name="SYNTAX_ERR" type="unsigned short" value="12" since="DOM Level 2"><descr><p>If an invalid or illegal string is specified.</p></descr></constant><constant id="DOMException-INVALID_MODIFICATION_ERR" name="INVALID_MODIFICATION_ERR" type="unsigned short" value="13" since="DOM Level 2"><descr><p>If an attempt is made to modify the type of the underlying object.</p></descr></constant><constant id="DOMException-NAMESPACE_ERR" name="NAMESPACE_ERR" type="unsigned short" value="14" since="DOM Level 2"><descr><p>If an attempt is made to create or change an object in a way which is incorrect with regard to namespaces.</p></descr></constant><constant id="DOMException-INVALID_ACCESS_ERR" name="INVALID_ACCESS_ERR" type="unsigned short" value="15" since="DOM Level 2"><descr><p>If a parameter or an operation is not supported by the underlying object.</p></descr></constant><constant id="DOMException-VALIDATION_ERR" name="VALIDATION_ERR" type="unsigned short" value="16" since="DOM Level 3"><descr><p>If a call to a method such as<code>insertBefore</code>or<code>removeChild</code>would make the<code>Node</code>invalid with respect to<termref def="dt-partially-valid">"partial validity"</termref>, this exception would be raised and the operation would not be done. This code is used in<bibref role="informative" ref="DOMVal"/>. Refer to this specification for further information.</p></descr></constant><constant id="DOMException-TYPE_MISMATCH_ERR" name="TYPE_MISMATCH_ERR" type="unsigned short" value="17" since="DOM Level 3"><descr><p>If the type of an object is incompatible with the expected type of the parameter associated to the object.</p></descr></constant></group>
  <interface name="DOMStringList" id="DOMStringList" since="DOM Level 3"><descr><p>The<code>DOMStringList</code>interface provides the abstraction of an ordered collection of<code>DOMString</code>values, without defining or constraining how this collection is implemented. The items in the<code>DOMStringList</code>are accessible via an integral index, starting from 0.</p></descr><method name="item" id="DOMStringList-item"><descr><p>Returns the<code>index</code>th item in the collection. If<code>index</code>is greater than or equal to the number of<code>DOMString</code>s in the list, this returns<code>null</code>.</p></descr><parameters><param name="index" type="unsigned long" attr="in"><descr><p>Index into the collection.</p></descr></param></parameters><returns type="DOMString"><descr><p>The<code>DOMString</code>at the<code>index</code>th position in the<code>DOMStringList</code>, or<code>null</code>if that is not a valid index.</p></descr></returns><raises></raises></method><attribute type="unsigned long" readonly="yes" name="length" id="DOMStringList-length"><descr><p>The number of<code>DOMString</code>s in the list. The range of valid child node indices is 0 to<code>length-1</code>inclusive.</p></descr></attribute><method name="contains" id="DOMStringList-contains"><descr><p>Test if a string is part of this<code>DOMStringList</code>.</p></descr><parameters><param name="str" type="DOMString" attr="in"><descr><p>The string to look for.</p></descr></param></parameters><returns type="boolean"><descr><p><code>true</code>if the string has been found,<code>false</code>otherwise.</p></descr></returns><raises></raises></method></interface>
  <interface name="NameList" id="NameList" since="DOM Level 3"><descr><p>The<code>NameList</code>interface provides the abstraction of an ordered collection of parallel pairs of name and namespace values (which could be null values), without defining or constraining how this collection is implemented. The items in the<code>NameList</code>are accessible via an integral index, starting from 0.</p></descr><method name="getName" id="NameList-getName"><descr><p>Returns the<code>index</code>th name item in the collection.</p></descr><parameters><param name="index" type="unsigned long" attr="in"><descr><p>Index into the collection.</p></descr></param></parameters><returns type="DOMString"><descr><p>The name at the<code>index</code>th position in the<code>NameList</code>, or<code>null</code>if there is no name for the specified index or if the index is out of range.</p></descr></returns><raises></raises></method><method name="getNamespaceURI" id="NameList-getNamespaceURI"><descr><p>Returns the<code>index</code>th namespaceURI item in the collection.</p></descr><parameters><param name="index" type="unsigned long" attr="in"><descr><p>Index into the collection.</p></descr></param></parameters><returns type="DOMString"><descr><p>The namespace URI at the<code>index</code>th position in the<code>NameList</code>, or<code>null</code>if there is no name for the specified index or if the index is out of range.</p></descr></returns><raises></raises></method><attribute type="unsigned long" readonly="yes" name="length" id="NameList-length"><descr><p>The number of pairs (name and namespaceURI) in the list. The range of valid child node indices is 0 to<code>length-1</code>inclusive.</p></descr></attribute><method name="contains" id="NameList-contains"><descr><p>Test if a name is part of this<code>NameList</code>.</p></descr><parameters><param name="str" type="DOMString" attr="in"><descr><p>The name to look for.</p></descr></param></parameters><returns type="boolean"><descr><p><code>true</code>if the name has been found,<code>false</code>otherwise.</p></descr></returns><raises></raises></method><method name="containsNS" id="NameList-containsNS"><descr><p>Test if the pair namespaceURI/name is part of this<code>NameList</code>.</p></descr><parameters><param name="namespaceURI" type="DOMString" attr="in"><descr><p>The namespace URI to look for.</p></descr></param><param name="name" type="DOMString" attr="in"><descr><p>The name to look for.</p></descr></param></parameters><returns type="boolean"><descr><p><code>true</code>if the pair namespaceURI/name has been found,<code>false</code>otherwise.</p></descr></returns><raises></raises></method></interface>
  <interface name="DOMImplementationList" id="DOMImplementationList" since="DOM Level 3"><descr><p>The<code>DOMImplementationList</code>interface provides the abstraction of an ordered collection of DOM implementations, without defining or constraining how this collection is implemented. The items in the<code>DOMImplementationList</code>are accessible via an integral index, starting from 0.</p></descr><method name="item" id="DOMImplementationList-item"><descr><p>Returns the<code>index</code>th item in the collection. If<code>index</code>is greater than or equal to the number of<code>DOMImplementation</code>s in the list, this returns<code>null</code>.</p></descr><parameters><param name="index" type="unsigned long" attr="in"><descr><p>Index into the collection.</p></descr></param></parameters><returns type="DOMImplementation"><descr><p>The<code>DOMImplementation</code>at the<code>index</code>th position in the<code>DOMImplementationList</code>, or<code>null</code>if that is not a valid index.</p></descr></returns><raises></raises></method><attribute type="unsigned long" readonly="yes" name="length" id="DOMImplementationList-length"><descr><p>The number of<code>DOMImplementation</code>s in the list. The range of valid child node indices is 0 to<code>length-1</code>inclusive.</p></descr></attribute></interface>
  <interface name="DOMImplementationSource" id="DOMImplementationSource" since="DOM Level 3"><descr><p>This interface permits a DOM implementer to supply one or more implementations, based upon requested features and versions, as specified in<specref ref="DOMFeatures"/>. Each implemented<code>DOMImplementationSource</code>object is listed in the binding-specific list of available sources so that its<code>DOMImplementation</code>objects are made available.</p></descr><method name="getDOMImplementation" id="ID-getDOMImpl"><descr><p>A method to request the first DOM implementation that supports the specified features.</p></descr><parameters><param name="features" type="DOMString" attr="in"><descr><p>A string that specifies which features and versions are required. This is a space separated list in which each feature is specified by its name optionally followed by a space and a version number.</p><p>This method returns the first item of the list returned by<code>getDOMImplementationList</code>.</p><p>As an example, the string<code>"XML 3.0 Traversal +Events 2.0"</code>will request a DOM implementation that supports the module "XML" for its 3.0 version, a module that support of the "Traversal" module for any version, and the module "Events" for its 2.0 version. The module "Events" must be accessible using the method<code>Node.getFeature()</code>and<code>DOMImplementation.getFeature()</code>.</p></descr></param></parameters><returns type="DOMImplementation"><descr><p>The first DOM implementation that support the desired features, or<code>null</code>if this source has none.</p></descr></returns><raises></raises></method><method name="getDOMImplementationList" id="ID-getDOMImpls"><descr><p>A method to request a list of DOM implementations that support the specified features and versions, as specified in<specref ref="DOMFeatures"/>.</p></descr><parameters><param name="features" type="DOMString" attr="in"><descr><p>A string that specifies which features and versions are required. This is a space separated list in which each feature is specified by its name optionally followed by a space and a version number. This is something like: "XML 3.0 Traversal +Events 2.0"</p></descr></param></parameters><returns type="DOMImplementationList"><descr><p>A list of DOM implementations that support the desired features.</p></descr></returns><raises></raises></method></interface>
  <interface name="DOMImplementation" id="ID-102161490"><descr><p>The<code>DOMImplementation</code>interface provides a number of methods for performing operations that are independent of any particular instance of the document object model.</p></descr><method name="hasFeature" id="ID-5CED94D7"><descr><p>Test if the DOM implementation implements a specific feature and version, as specified in<specref ref="DOMFeatures"/>.</p></descr><parameters><param name="feature" type="DOMString" attr="in"><descr><p>The name of the feature to test.</p></descr></param><param name="version" type="DOMString" attr="in"><descr><p>This is the version number of the feature to test.</p></descr></param></parameters><returns type="boolean"><descr><p><code>true</code>if the feature is implemented in the specified version,<code>false</code>otherwise.</p></descr></returns><raises></raises></method><method name="createDocumentType" id="Level-2-Core-DOM-createDocType" since="DOM Level 2"><descr><p>Creates an empty<code>DocumentType</code>node. Entity declarations and notations are not made available. Entity reference expansions and default attribute additions do not occur..</p></descr><parameters><param name="qualifiedName" type="DOMString" attr="in"><descr><p>The<termref def="dt-qualifiedname">qualified name</termref>of the document type to be created.</p></descr></param><param name="publicId" type="DOMString" attr="in"><descr><p>The external subset public identifier.</p></descr></param><param name="systemId" type="DOMString" attr="in"><descr><p>The external subset system identifier.</p></descr></param></parameters><returns type="DocumentType"><descr><p>A new<code>DocumentType</code>node with<code>Node.ownerDocument</code>set to<code>null</code>.</p></descr></returns><raises><exception name="DOMException"><descr><p>INVALID_CHARACTER_ERR: Raised if the specified qualified name is not an XML name according to<bibref ref="XML"/>.</p><p>NAMESPACE_ERR: Raised if the<code>qualifiedName</code>is malformed.</p><p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature "XML" and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p></descr></exception></raises></method><method name="createDocument" id="Level-2-Core-DOM-createDocument" since="DOM Level 2"><descr><p>Creates a DOM Document object of the specified type with its document element.</p><p>Note that based on the<code>DocumentType</code>given to create the document, the implementation may instantiate specialized<code>Document</code>objects that support additional features than the "Core", such as "HTML"<bibref role="informative" ref="DOM2HTML"/>. On the other hand, setting the<code>DocumentType</code>after the document was created makes this very unlikely to happen. Alternatively, specialized<code>Document</code>creation methods, such as<code>createHTMLDocument</code><bibref role="informative" ref="DOM2HTML"/>, can be used to obtain specific types of<code>Document</code>objects.</p></descr><parameters><param name="namespaceURI" type="DOMString" attr="in"><descr><p>The<termref def="dt-namespaceURI">namespace URI</termref>of the document element to create or<code>null</code>.</p></descr></param><param name="qualifiedName" type="DOMString" attr="in"><descr><p>The<termref def="dt-qualifiedname">qualified name</termref>of the document element to be created or<code>null</code>.</p></descr></param><param name="doctype" type="DocumentType" attr="in"><descr><p>The type of document to be created or<code>null</code>.</p><p>When<code>doctype</code>is not<code>null</code>, its<code>Node.ownerDocument</code>attribute is set to the document being created.</p></descr></param></parameters><returns type="Document"><descr><p>A new<code>Document</code>object with its document element. If the<code>NamespaceURI</code>,<code>qualifiedName</code>, and<code>doctype</code>are<code>null</code>, the returned<code>Document</code>is empty with no document element.</p></descr></returns><raises><exception name="DOMException"><descr><p>INVALID_CHARACTER_ERR: Raised if the specified qualified name is not an XML name according to<bibref ref="XML"/>.</p><p>NAMESPACE_ERR: Raised if the<code>qualifiedName</code>is malformed, if the<code>qualifiedName</code>has a prefix and the<code>namespaceURI</code>is<code>null</code>, or if the<code>qualifiedName</code>is<code>null</code>and the<code>namespaceURI</code>is different from<code>null</code>, or if the<code>qualifiedName</code>has a prefix that is "xml" and the<code>namespaceURI</code>is different from "<loc href="http://www.w3.org/XML/1998/namespace" type="simple" show="replace" actuate="onRequest">http://www.w3.org/XML/1998/namespace</loc>"<bibref ref="Namespaces"/>, or if the DOM implementation does not support the<code>"XML"</code>feature but a non-null namespace URI was provided, since namespaces were defined by XML.</p><p>WRONG_DOCUMENT_ERR: Raised if<code>doctype</code>has already been used with a different document or was created from a different implementation.</p><p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature "XML" and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p></descr></exception></raises></method><method name="getFeature" id="DOMImplementation3-getFeature" since="DOM Level 3"><descr><p>This method returns a specialized object which implements the specialized APIs of the specified feature and version, as specified in<specref ref="DOMFeatures"/>. The specialized object may also be obtained by using binding-specific casting methods but is not necessarily expected to, as discussed in<specref ref="Embedded-DOM"/>. This method also allow the implementation to provide specialized objects which do not support the<code>DOMImplementation</code>interface.</p></descr><parameters><param name="feature" type="DOMString" attr="in"><descr><p>The name of the feature requested. Note that any plus sign "+" prepended to the name of the feature will be ignored since it is not significant in the context of this method.</p></descr></param><param name="version" type="DOMString" attr="in"><descr><p>This is the version number of the feature to test.</p></descr></param></parameters><returns type="DOMObject"><descr><p>Returns an object which implements the specialized APIs of the specified feature and version, if any, or<code>null</code>if there is no object which implements interfaces associated with that feature. If the<code>DOMObject</code>returned by this method implements the<code>DOMImplementation</code>interface, it must delegate to the primary core<code>DOMImplementation</code>and not return results inconsistent with the primary core<code>DOMImplementation</code>such as<code>hasFeature</code>,<code>getFeature</code>, etc.</p></descr></returns><raises></raises></method></interface>
  <interface name="DocumentFragment" inherits="Node" id="ID-B63ED1A3"><descr><p><code>DocumentFragment</code>is a "lightweight" or "minimal"<code>Document</code>object. It is very common to want to be able to extract a portion of a document's tree or to create a new fragment of a document. Imagine implementing a user command like cut or rearranging a document by moving fragments around. It is desirable to have an object which can hold such fragments and it is quite natural to use a Node for this purpose. While it is true that a<code>Document</code>object could fulfill this role, a<code>Document</code>object can potentially be a heavyweight object, depending on the underlying implementation. What is really needed for this is a very lightweight object.<code>DocumentFragment</code>is such an object.</p><p>Furthermore, various operations -- such as inserting nodes as children of another<code>Node</code>-- may take<code>DocumentFragment</code>objects as arguments; this results in all the child nodes of the<code>DocumentFragment</code>being moved to the child list of this node.</p><p>The children of a<code>DocumentFragment</code>node are zero or more nodes representing the tops of any sub-trees defining the structure of the document.<code>DocumentFragment</code>nodes do not need to be<termref def="dt-well-formed">well-formed XML documents</termref>(although they do need to follow the rules imposed upon well-formed XML parsed entities, which can have multiple top nodes). For example, a<code>DocumentFragment</code>might have only one child and that child node could be a<code>Text</code>node. Such a structure model represents neither an HTML document nor a well-formed XML document.</p><p>When a<code>DocumentFragment</code>is inserted into a<code>Document</code>(or indeed any other<code>Node</code>that may take children) the children of the<code>DocumentFragment</code>and not the<code>DocumentFragment</code>itself are inserted into the<code>Node</code>. This makes the<code>DocumentFragment</code>very useful when the user wishes to create nodes that are<termref def="dt-sibling">siblings</termref>; the<code>DocumentFragment</code>acts as the parent of these nodes so that the user can use the standard methods from the<code>Node</code>interface, such as<code>Node.insertBefore</code>and<code>Node.appendChild</code>.</p></descr></interface>
  <interface name="Document" inherits="Node" id="i-Document"><descr><p>The<code>Document</code>interface represents the entire HTML or XML document. Conceptually, it is the<termref def="dt-root-node">root</termref>of the document tree, and provides the primary access to the document's data.</p><p>Since elements, text nodes, comments, processing instructions, etc. cannot exist outside the context of a<code>Document</code>, the<code>Document</code>interface also contains the factory methods needed to create these objects. The<code>Node</code>objects created have a<code>ownerDocument</code>attribute which associates them with the<code>Document</code>within whose context they were created.</p></descr><attribute id="ID-B63ED1A31" name="doctype" type="DocumentType" readonly="yes" version="DOM Level 3"><descr><p>The Document Type Declaration (see<code>DocumentType</code>) associated with this document. For XML documents without a document type declaration this returns<code>null</code>. For HTML documents, a<code>DocumentType</code>object may be returned, independently of the presence or absence of document type declaration in the HTML document.</p><p>This provides direct access to the<code>DocumentType</code>node, child node of this<code>Document</code>. This node can be set at document creation time and later changed through the use of child nodes manipulation methods, such as<code>Node.insertBefore</code>, or<code>Node.replaceChild</code>. Note, however, that while some implementations may instantiate different types of<code>Document</code>objects supporting additional features than the "Core", such as "HTML"<bibref role="informative" ref="DOM2HTML"/>, based on the<code>DocumentType</code>specified at creation time, changing it afterwards is very unlikely to result in a change of the features supported.</p></descr></attribute><attribute readonly="yes" name="implementation" type="DOMImplementation" id="ID-1B793EBA"><descr><p>The<code>DOMImplementation</code>object that handles this document. A DOM application may use objects from multiple implementations.</p></descr></attribute><attribute readonly="yes" name="documentElement" type="Element" id="ID-87CD092"><descr><p>This is a<termref def="dt-convenience">convenience</termref>attribute that allows direct access to the child node that is the<termref def="dt-document-element">document element</termref>of the document.</p></descr></attribute><method name="createElement" id="ID-2141741547"><descr><p>Creates an element of the type specified. Note that the instance returned implements the<code>Element</code>interface, so attributes can be specified directly on the returned object.</p><p>In addition, if there are known attributes with default values,<code>Attr</code>nodes representing them are automatically created and attached to the element.</p><p>To create an element with a<termref def="dt-qualifiedname">qualified name</termref>and<termref def="dt-namespaceURI">namespace URI</termref>, use the<code>createElementNS</code>method.</p></descr><parameters><param name="tagName" type="DOMString" attr="in"><descr><p>The name of the element type to instantiate. For XML, this is case-sensitive, otherwise it depends on the case-sensitivity of the markup language in use. In that case, the name is mapped to the canonical form of that markup by the DOM implementation.</p></descr></param></parameters><returns type="Element"><descr><p>A new<code>Element</code>object with the<code>nodeName</code>attribute set to<code>tagName</code>, and<code>localName</code>,<code>prefix</code>, and<code>namespaceURI</code>set to<code>null</code>.</p></descr></returns><raises><exception name="DOMException"><descr><p>INVALID_CHARACTER_ERR: Raised if the specified name is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p></descr></exception></raises></method><method name="createDocumentFragment" id="ID-35CB04B5"><descr><p>Creates an empty<code>DocumentFragment</code>object.</p></descr><parameters></parameters><returns type="DocumentFragment"><descr><p>A new<code>DocumentFragment</code>.</p></descr></returns><raises></raises></method><method name="createTextNode" id="ID-1975348127"><descr><p>Creates a<code>Text</code>node given the specified string.</p></descr><parameters><param name="data" type="DOMString" attr="in"><descr><p>The data for the node.</p></descr></param></parameters><returns type="Text"><descr><p>The new<code>Text</code>object.</p></descr></returns><raises></raises></method><method name="createComment" id="ID-1334481328"><descr><p>Creates a<code>Comment</code>node given the specified string.</p></descr><parameters><param name="data" type="DOMString" attr="in"><descr><p>The data for the node.</p></descr></param></parameters><returns type="Comment"><descr><p>The new<code>Comment</code>object.</p></descr></returns><raises></raises></method><method name="createCDATASection" id="ID-D26C0AF8"><descr><p>Creates a<code>CDATASection</code>node whose value is the specified string.</p></descr><parameters><param name="data" type="DOMString" attr="in"><descr><p>The data for the<code>CDATASection</code>contents.</p></descr></param></parameters><returns type="CDATASection"><descr><p>The new<code>CDATASection</code>object.</p></descr></returns><raises><exception name="DOMException"><descr><p>NOT_SUPPORTED_ERR: Raised if this document is an HTML document.</p></descr></exception></raises></method><method name="createProcessingInstruction" id="ID-135944439"><descr><p>Creates a<code>ProcessingInstruction</code>node given the specified name and data strings.</p></descr><parameters><param name="target" type="DOMString" attr="in"><descr><p>The target part of the processing instruction.</p><p>Unlike<code>Document.createElementNS</code>or<code>Document.createAttributeNS</code>, no namespace well-formed checking is done on the target name. Applications should invoke<code>Document.normalizeDocument()</code>with the parameter "<termref def="parameter-namespaces">namespaces</termref>" set to<code>true</code>in order to ensure that the target name is namespace well-formed.</p></descr></param><param name="data" type="DOMString" attr="in"><descr><p>The data for the node.</p></descr></param></parameters><returns type="ProcessingInstruction"><descr><p>The new<code>ProcessingInstruction</code>object.</p></descr></returns><raises><exception name="DOMException"><descr><p>INVALID_CHARACTER_ERR: Raised if the specified target is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p><p>NOT_SUPPORTED_ERR: Raised if this document is an HTML document.</p></descr></exception></raises></method><method name="createAttribute" id="ID-1084891198"><descr><p>Creates an<code>Attr</code>of the given name. Note that the<code>Attr</code>instance can then be set on an<code>Element</code>using the<code>setAttributeNode</code>method.</p><p>To create an attribute with a<termref def="dt-qualifiedname">qualified name</termref>and<termref def="dt-namespaceURI">namespace URI</termref>, use the<code>createAttributeNS</code>method.</p></descr><parameters><param name="name" type="DOMString" attr="in"><descr><p>The name of the attribute.</p></descr></param></parameters><returns type="Attr"><descr><p>A new<code>Attr</code>object with the<code>nodeName</code>attribute set to<code>name</code>, and<code>localName</code>,<code>prefix</code>, and<code>namespaceURI</code>set to<code>null</code>. The value of the attribute is the empty string.</p></descr></returns><raises><exception name="DOMException"><descr><p>INVALID_CHARACTER_ERR: Raised if the specified name is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p></descr></exception></raises></method><method name="createEntityReference" id="ID-392B75AE"><descr><p>Creates an<code>EntityReference</code>object. In addition, if the referenced entity is known, the child list of the<code>EntityReference</code>node is made the same as that of the corresponding<code>Entity</code>node.</p><note><p>If any descendant of the<code>Entity</code>node has an unbound<termref def="dt-namespaceprefix">namespace prefix</termref>, the corresponding descendant of the created<code>EntityReference</code>node is also unbound; (its<code>namespaceURI</code>is<code>null</code>). The DOM Level 2 and 3 do not support any mechanism to resolve namespace prefixes in this case.</p></note></descr><parameters><param name="name" type="DOMString" attr="in"><descr><p>The name of the entity to reference.</p><p>Unlike<code>Document.createElementNS</code>or<code>Document.createAttributeNS</code>, no namespace well-formed checking is done on the entity name. Applications should invoke<code>Document.normalizeDocument()</code>with the parameter "<termref def="parameter-namespaces">namespaces</termref>" set to<code>true</code>in order to ensure that the entity name is namespace well-formed.</p></descr></param></parameters><returns type="EntityReference"><descr><p>The new<code>EntityReference</code>object.</p></descr></returns><raises><exception name="DOMException"><descr><p>INVALID_CHARACTER_ERR: Raised if the specified name is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p><p>NOT_SUPPORTED_ERR: Raised if this document is an HTML document.</p></descr></exception></raises></method><method name="getElementsByTagName" id="ID-A6C9094"><descr><p>Returns a<code>NodeList</code>of all the<code>Elements</code>in<termref def="dt-document-order">document order</termref>with a given tag name and are contained in the document.</p></descr><parameters><param name="tagname" type="DOMString" attr="in"><descr><p>The name of the tag to match on. The special value "*" matches all tags. For XML, the<code>tagname</code>parameter is case-sensitive, otherwise it depends on the case-sensitivity of the markup language in use.</p></descr></param></parameters><returns type="NodeList"><descr><p>A new<code>NodeList</code>object containing all the matched<code>Elements</code>.</p></descr></returns><raises></raises></method><method name="importNode" id="Core-Document-importNode" since="DOM Level 2"><descr><p>Imports a node from another document to this document, without altering or removing the source node from the original document; this method creates a new copy of the source node. The returned node has no parent; (<code>parentNode</code>is<code>null</code>).</p><p>For all nodes, importing a node creates a node object owned by the importing document, with attribute values identical to the source node's<code>nodeName</code>and<code>nodeType</code>, plus the attributes related to namespaces (<code>prefix</code>,<code>localName</code>, and<code>namespaceURI</code>). As in the<code>cloneNode</code>operation, the source node is not altered. User data associated to the imported node is not carried over. However, if any<code>UserDataHandlers</code>has been specified along with the associated data these handlers will be called with the appropriate parameters before this method returns.</p><p>Additional information is copied as appropriate to the<code>nodeType</code>, attempting to mirror the behavior expected if a fragment of XML or HTML source was copied from one document to another, recognizing that the two documents may have different DTDs in the XML case. The following list describes the specifics for each type of node.<glist><gitem><label>ATTRIBUTE_NODE</label><def><p>The<code>ownerElement</code>attribute is set to<code>null</code>and the<code>specified</code>flag is set to<code>true</code>on the generated<code>Attr</code>. The<termref def="dt-descendant">descendants</termref>of the source<code>Attr</code>are recursively imported and the resulting nodes reassembled to form the corresponding subtree.</p><p>Note that the<code>deep</code>parameter has no effect on<code>Attr</code>nodes; they always carry their children with them when imported.</p></def></gitem><gitem><label>DOCUMENT_FRAGMENT_NODE</label><def><p>If the<code>deep</code>option was set to<code>true</code>, the<termref def="dt-descendant">descendants</termref>of the source<code>DocumentFragment</code>are recursively imported and the resulting nodes reassembled under the imported<code>DocumentFragment</code>to form the corresponding subtree. Otherwise, this simply generates an empty<code>DocumentFragment</code>.</p></def></gitem><gitem><label>DOCUMENT_NODE</label><def><p><code>Document</code>nodes cannot be imported.</p></def></gitem><gitem><label>DOCUMENT_TYPE_NODE</label><def><p><code>DocumentType</code>nodes cannot be imported.</p></def></gitem><gitem><label>ELEMENT_NODE</label><def><p><emph>Specified</emph>attribute nodes of the source element are imported, and the generated<code>Attr</code>nodes are attached to the generated<code>Element</code>. Default attributes are<emph>not</emph>copied, though if the document being imported into defines default attributes for this element name, those are assigned. If the<code>importNode</code><code>deep</code>parameter was set to<code>true</code>, the<termref def="dt-descendant">descendants</termref>of the source element are recursively imported and the resulting nodes reassembled to form the corresponding subtree.</p></def></gitem><gitem><label>ENTITY_NODE</label><def><p><code>Entity</code>nodes can be imported, however in the current release of the DOM the<code>DocumentType</code>is readonly. Ability to add these imported nodes to a<code>DocumentType</code>will be considered for addition to a future release of the DOM.</p><p>On import, the<code>publicId</code>,<code>systemId</code>, and<code>notationName</code>attributes are copied. If a<code>deep</code>import is requested, the<termref def="dt-descendant">descendants</termref>of the the source<code>Entity</code>are recursively imported and the resulting nodes reassembled to form the corresponding subtree.</p></def></gitem><gitem><label>ENTITY_REFERENCE_NODE</label><def><p>Only the<code>EntityReference</code>itself is copied, even if a<code>deep</code>import is requested, since the source and destination documents might have defined the entity differently. If the document being imported into provides a definition for this entity name, its value is assigned.</p></def></gitem><gitem><label>NOTATION_NODE</label><def><p><code>Notation</code>nodes can be imported, however in the current release of the DOM the<code>DocumentType</code>is readonly. Ability to add these imported nodes to a<code>DocumentType</code>will be considered for addition to a future release of the DOM.</p><p>On import, the<code>publicId</code>and<code>systemId</code>attributes are copied.</p><p>Note that the<code>deep</code>parameter has no effect on this type of nodes since they cannot have any children.</p></def></gitem><gitem><label>PROCESSING_INSTRUCTION_NODE</label><def><p>The imported node copies its<code>target</code>and<code>data</code>values from those of the source node.</p><p>Note that the<code>deep</code>parameter has no effect on this type of nodes since they cannot have any children.</p></def></gitem><gitem><label>TEXT_NODE, CDATA_SECTION_NODE, COMMENT_NODE</label><def><p>These three types of nodes inheriting from<code>CharacterData</code>copy their<code>data</code>and<code>length</code>attributes from those of the source node.</p><p>Note that the<code>deep</code>parameter has no effect on these types of nodes since they cannot have any children.</p></def></gitem></glist></p></descr><parameters><param name="importedNode" type="Node" attr="in"><descr><p>The node to import.</p></descr></param><param name="deep" type="boolean" attr="in"><descr><p>If<code>true</code>, recursively import the subtree under the specified node; if<code>false</code>, import only the node itself, as explained above. This has no effect on nodes that cannot have any children, and on<code>Attr</code>, and<code>EntityReference</code>nodes.</p></descr></param></parameters><returns type="Node"><descr><p>The imported node that belongs to this<code>Document</code>.</p></descr></returns><raises><exception name="DOMException" version="DOM Level 3"><descr><p>NOT_SUPPORTED_ERR: Raised if the type of node being imported is not supported.</p><p>INVALID_CHARACTER_ERR: Raised if one of the imported names is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute. This may happen when importing an XML 1.1<bibref role="informative" ref="XML11"/>element into an XML 1.0 document, for instance.</p></descr></exception></raises></method><method name="createElementNS" id="ID-DocCrElNS" since="DOM Level 2"><descr><p>Creates an element of the given<termref def="dt-qualifiedname">qualified name</termref>and<termref def="dt-namespaceURI">namespace URI</termref>.</p><p>Per<bibref ref="Namespaces"/>, applications must use the value<code>null</code>as the namespaceURI parameter for methods if they wish to have no namespace.</p></descr><parameters><param name="namespaceURI" type="DOMString" attr="in"><descr><p>The<termref def="dt-namespaceURI">namespace URI</termref>of the element to create.</p></descr></param><param name="qualifiedName" type="DOMString" attr="in"><descr><p>The<termref def="dt-qualifiedname">qualified name</termref>of the element type to instantiate.</p></descr></param></parameters><returns type="Element"><descr><p>A new<code>Element</code>object with the following attributes:</p><table cellpadding="3" summary="Layout table: the first cell the name property,                the second cell contains his initial value"><tbody><tr><th rowspan="1" colspan="1">Attribute</th><th rowspan="1" colspan="1">Value</th></tr><tr><td rowspan="1" colspan="1"><code>Node.nodeName</code></td><td rowspan="1" colspan="1"><code>qualifiedName</code></td></tr><tr><td rowspan="1" colspan="1"><code>Node.namespaceURI</code></td><td rowspan="1" colspan="1"><code>namespaceURI</code></td></tr><tr><td rowspan="1" colspan="1"><code>Node.prefix</code></td><td rowspan="1" colspan="1">prefix, extracted from<code>qualifiedName</code>, or<code>null</code>if there is no prefix</td></tr><tr><td rowspan="1" colspan="1"><code>Node.localName</code></td><td rowspan="1" colspan="1"><termref def="dt-localname">local name</termref>, extracted from<code>qualifiedName</code></td></tr><tr><td rowspan="1" colspan="1"><code>Element.tagName</code></td><td rowspan="1" colspan="1"><code>qualifiedName</code></td></tr></tbody></table></descr></returns><raises><exception name="DOMException"><descr><p>INVALID_CHARACTER_ERR: Raised if the specified<code>qualifiedName</code>is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p><p>NAMESPACE_ERR: Raised if the<code>qualifiedName</code>is a malformed<termref def="dt-qualifiedname">qualified name</termref>, if the<code>qualifiedName</code>has a prefix and the<code>namespaceURI</code>is<code>null</code>, or if the<code>qualifiedName</code>has a prefix that is "xml" and the<code>namespaceURI</code>is different from "<loc href="http://www.w3.org/XML/1998/namespace" type="simple" show="replace" actuate="onRequest">http://www.w3.org/XML/1998/namespace</loc>"<bibref ref="Namespaces"/>, or if the<code>qualifiedName</code>or its prefix is "xmlns" and the<code>namespaceURI</code>is different from "<loc href="http://www.w3.org/2000/xmlns/" type="simple" show="replace" actuate="onRequest">http://www.w3.org/2000/xmlns/</loc>", or if the<code>namespaceURI</code>is "<loc href="http://www.w3.org/2000/xmlns/" type="simple" show="replace" actuate="onRequest">http://www.w3.org/2000/xmlns/</loc>" and neither the<code>qualifiedName</code>nor its prefix is "xmlns".</p><p>NOT_SUPPORTED_ERR: Always thrown if the current document does not support the<code>"XML"</code>feature, since namespaces were defined by XML.</p></descr></exception></raises></method><method name="createAttributeNS" id="ID-DocCrAttrNS" since="DOM Level 2"><descr><p>Creates an attribute of the given<termref def="dt-qualifiedname">qualified name</termref>and<termref def="dt-namespaceURI">namespace URI</termref>.</p><p>Per<bibref ref="Namespaces"/>, applications must use the value<code>null</code>as the<code>namespaceURI</code>parameter for methods if they wish to have no namespace.</p></descr><parameters><param name="namespaceURI" type="DOMString" attr="in"><descr><p>The<termref def="dt-namespaceURI">namespace URI</termref>of the attribute to create.</p></descr></param><param name="qualifiedName" type="DOMString" attr="in"><descr><p>The<termref def="dt-qualifiedname">qualified name</termref>of the attribute to instantiate.</p></descr></param></parameters><returns type="Attr"><descr><p>A new<code>Attr</code>object with the following attributes:</p><table cellpadding="3" summary="Layout table: the first cell the name property,                the second cell contains his initial value"><tbody><tr><th rowspan="1" colspan="1">Attribute</th><th rowspan="1" colspan="1">Value</th></tr><tr><td rowspan="1" colspan="1"><code>Node.nodeName</code></td><td rowspan="1" colspan="1">qualifiedName</td></tr><tr><td rowspan="1" colspan="1"><code>Node.namespaceURI</code></td><td rowspan="1" colspan="1"><code>namespaceURI</code></td></tr><tr><td rowspan="1" colspan="1"><code>Node.prefix</code></td><td rowspan="1" colspan="1">prefix, extracted from<code>qualifiedName</code>, or<code>null</code>if there is no prefix</td></tr><tr><td rowspan="1" colspan="1"><code>Node.localName</code></td><td rowspan="1" colspan="1"><termref def="dt-localname">local name</termref>, extracted from<code>qualifiedName</code></td></tr><tr><td rowspan="1" colspan="1"><code>Attr.name</code></td><td rowspan="1" colspan="1"><code>qualifiedName</code></td></tr><tr><td rowspan="1" colspan="1"><code>Node.nodeValue</code></td><td rowspan="1" colspan="1">the empty string</td></tr></tbody></table></descr></returns><raises><exception name="DOMException"><descr><p>INVALID_CHARACTER_ERR: Raised if the specified<code>qualifiedName</code>is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p><p>NAMESPACE_ERR: Raised if the<code>qualifiedName</code>is a malformed<termref def="dt-qualifiedname">qualified name</termref>, if the<code>qualifiedName</code>has a prefix and the<code>namespaceURI</code>is<code>null</code>, if the<code>qualifiedName</code>has a prefix that is "xml" and the<code>namespaceURI</code>is different from "<loc href="http://www.w3.org/XML/1998/namespace" type="simple" show="replace" actuate="onRequest">http://www.w3.org/XML/1998/namespace</loc>", if the<code>qualifiedName</code>or its prefix is "xmlns" and the<code>namespaceURI</code>is different from "<loc href="http://www.w3.org/2000/xmlns/" type="simple" show="replace" actuate="onRequest">http://www.w3.org/2000/xmlns/</loc>", or if the<code>namespaceURI</code>is "<loc href="http://www.w3.org/2000/xmlns/" type="simple" show="replace" actuate="onRequest">http://www.w3.org/2000/xmlns/</loc>" and neither the<code>qualifiedName</code>nor its prefix is "xmlns".</p><p>NOT_SUPPORTED_ERR: Always thrown if the current document does not support the<code>"XML"</code>feature, since namespaces were defined by XML.</p></descr></exception></raises></method><method name="getElementsByTagNameNS" id="ID-getElBTNNS" since="DOM Level 2"><descr><p>Returns a<code>NodeList</code>of all the<code>Elements</code>with a given<termref def="dt-localname">local name</termref>and<termref def="dt-namespaceURI">namespace URI</termref>in<termref def="dt-document-order">document order</termref>.</p></descr><parameters><param name="namespaceURI" type="DOMString" attr="in"><descr><p>The<termref def="dt-namespaceURI">namespace URI</termref>of the elements to match on. The special value<code>"*"</code>matches all namespaces.</p></descr></param><param name="localName" type="DOMString" attr="in"><descr><p>The<termref def="dt-localname">local name</termref>of the elements to match on. The special value "*" matches all local names.</p></descr></param></parameters><returns type="NodeList"><descr><p>A new<code>NodeList</code>object containing all the matched<code>Elements</code>.</p></descr></returns><raises></raises></method><method name="getElementById" id="ID-getElBId" since="DOM Level 2"><descr><p>Returns the<code>Element</code>that has an ID attribute with the given value. If no such element exists, this returns<code>null</code>. If more than one element has an ID attribute with that value, what is returned is undefined.</p><p>The DOM implementation is expected to use the attribute<code>Attr.isId</code>to determine if an attribute is of type ID.</p><note><p>Attributes with the name "ID" or "id" are not of type ID unless so defined.</p></note></descr><parameters><param name="elementId" type="DOMString" attr="in"><descr><p>The unique<code>id</code>value for an element.</p></descr></param></parameters><returns type="Element"><descr><p>The matching element or<code>null</code>if there is none.</p></descr></returns><raises></raises></method><attribute readonly="yes" type="DOMString" name="inputEncoding" id="Document3-inputEncoding" since="DOM Level 3"><descr><p>An attribute specifying the encoding used for this document at the time of the parsing. This is<code>null</code>when it is not known, such as when the<code>Document</code>was created in memory.</p></descr></attribute><attribute readonly="yes" type="DOMString" name="xmlEncoding" id="Document3-encoding" since="DOM Level 3"><descr><p>An attribute specifying, as part of the<xspecref href="http://www.w3.org/TR/2004/REC-xml-20040204#NT-XMLDecl" type="simple" show="new" actuate="onRequest">XML declaration</xspecref>, the encoding of this document. This is<code>null</code>when unspecified or when it is not known, such as when the<code>Document</code>was created in memory.</p></descr></attribute><attribute readonly="no" type="boolean" name="xmlStandalone" id="Document3-standalone" since="DOM Level 3"><descr><p>An attribute specifying, as part of the<xspecref href="http://www.w3.org/TR/2004/REC-xml-20040204#NT-XMLDecl" type="simple" show="new" actuate="onRequest">XML declaration</xspecref>, whether this document is standalone. This is<code>false</code>when unspecified.</p><note><p>No verification is done on the value when setting this attribute. Applications should use<code>Document.normalizeDocument()</code>with the "<termref def="parameter-validate">validate</termref>" parameter to verify if the value matches the<xspecref href="http://www.w3.org/TR/2004/REC-xml-20040204#sec-rmd" type="simple" show="new" actuate="onRequest">validity constraint for standalone document declaration</xspecref>as defined in<bibref ref="XML"/>.</p></note></descr><setraises><exception name="DOMException"><descr><p>NOT_SUPPORTED_ERR: Raised if this document does not support the "XML" feature.</p></descr></exception></setraises></attribute><attribute readonly="no" type="DOMString" name="xmlVersion" id="Document3-version" since="DOM Level 3"><descr><p>An attribute specifying, as part of the<xspecref href="http://www.w3.org/TR/2004/REC-xml-20040204#NT-XMLDecl" type="simple" show="new" actuate="onRequest">XML declaration</xspecref>, the version number of this document. If there is no declaration and if this document supports the "XML" feature, the value is<code>"1.0"</code>. If this document does not support the "XML" feature, the value is always<code>null</code>. Changing this attribute will affect methods that check for invalid characters in XML names. Application should invoke<code>Document.normalizeDocument()</code>in order to check for invalid characters in the<code>Node</code>s that are already part of this<code>Document</code>.</p><p>DOM applications may use the<code>DOMImplementation.hasFeature(feature, version)</code>method with parameter values "XMLVersion" and "1.0" (respectively) to determine if an implementation supports<bibref ref="XML"/>. DOM applications may use the same method with parameter values "XMLVersion" and "1.1" (respectively) to determine if an implementation supports<bibref ref="XML11"/>. In both cases, in order to support XML, an implementation must also support the "XML" feature defined in this specification.<code>Document</code>objects supporting a version of the "XMLVersion" feature must not raise a<code>NOT_SUPPORTED_ERR</code>exception for the same version number when using<code>Document.xmlVersion</code>.</p></descr><setraises><exception name="DOMException"><descr><p>NOT_SUPPORTED_ERR: Raised if the version is set to a value that is not supported by this<code>Document</code>or if this document does not support the "XML" feature.</p></descr></exception></setraises></attribute><attribute readonly="no" type="boolean" name="strictErrorChecking" id="Document3-strictErrorChecking" since="DOM Level 3"><descr><p>An attribute specifying whether error checking is enforced or not. When set to<code>false</code>, the implementation is free to not test every possible error case normally defined on DOM operations, and not raise any<code>DOMException</code>on DOM operations or report errors while using<code>Document.normalizeDocument()</code>. In case of error, the behavior is undefined. This attribute is<code>true</code>by default.</p></descr></attribute><attribute name="documentURI" id="Document3-documentURI" type="DOMString" readonly="no" since="DOM Level 3"><descr><p>The location of the document or<code>null</code>if undefined or if the<code>Document</code>was created using<code>DOMImplementation.createDocument</code>. No lexical checking is performed when setting this attribute; this could result in a<code>null</code>value returned when using<code>Node.baseURI</code>.</p><p>Beware that when the<code>Document</code>supports the feature "HTML"<bibref role="informative" ref="DOM2HTML"/>, the href attribute of the HTML BASE element takes precedence over this attribute when computing<code>Node.baseURI</code>.</p></descr></attribute><method name="adoptNode" id="Document3-adoptNode" since="DOM Level 3"><descr><p>Attempts to adopt a node from another document to this document. If supported, it changes the<code>ownerDocument</code>of the source node, its children, as well as the attached attribute nodes if there are any. If the source node has a parent it is first removed from the child list of its parent. This effectively allows moving a subtree from one document to another (unlike<code>importNode()</code>which create a copy of the source node instead of moving it). When it fails, applications should use<code>Document.importNode()</code>instead. Note that if the adopted node is already part of this document (i.e. the source and target document are the same), this method still has the effect of removing the source node from the child list of its parent, if any. The following list describes the specifics for each type of node.<glist><gitem><label>ATTRIBUTE_NODE</label><def><p>The<code>ownerElement</code>attribute is set to<code>null</code>and the<code>specified</code>flag is set to<code>true</code>on the adopted<code>Attr</code>. The descendants of the source<code>Attr</code>are recursively adopted.</p></def></gitem><gitem><label>DOCUMENT_FRAGMENT_NODE</label><def><p>The descendants of the source node are recursively adopted.</p></def></gitem><gitem><label>DOCUMENT_NODE</label><def><p><code>Document</code>nodes cannot be adopted.</p></def></gitem><gitem><label>DOCUMENT_TYPE_NODE</label><def><p><code>DocumentType</code>nodes cannot be adopted.</p></def></gitem><gitem><label>ELEMENT_NODE</label><def><p><emph>Specified</emph>attribute nodes of the source element are adopted. Default attributes are discarded, though if the document being adopted into defines default attributes for this element name, those are assigned. The descendants of the source element are recursively adopted.</p></def></gitem><gitem><label>ENTITY_NODE</label><def><p><code>Entity</code>nodes cannot be adopted.</p></def></gitem><gitem><label>ENTITY_REFERENCE_NODE</label><def><p>Only the<code>EntityReference</code>node itself is adopted, the descendants are discarded, since the source and destination documents might have defined the entity differently. If the document being imported into provides a definition for this entity name, its value is assigned.</p></def></gitem><gitem><label>NOTATION_NODE</label><def><p><code>Notation</code>nodes cannot be adopted.</p></def></gitem><gitem><label>PROCESSING_INSTRUCTION_NODE, TEXT_NODE, CDATA_SECTION_NODE, COMMENT_NODE</label><def><p>These nodes can all be adopted. No specifics.</p></def></gitem></glist></p><note><p>Since it does not create new nodes unlike the<code>Document.importNode()</code>method, this method does not raise an<code>INVALID_CHARACTER_ERR</code>exception, and applications should use the<code>Document.normalizeDocument()</code>method to check if an imported name is not an XML name according to the XML version in use.</p></note></descr><parameters><param attr="in" type="Node" name="source"><descr><p>The node to move into this document.</p></descr></param></parameters><returns type="Node"><descr><p>The adopted node, or<code>null</code>if this operation fails, such as when the source node comes from a different implementation.</p></descr></returns><raises><exception name="DOMException"><descr><p>NOT_SUPPORTED_ERR: Raised if the source node is of type<code>DOCUMENT</code>,<code>DOCUMENT_TYPE</code>.</p><p>NO_MODIFICATION_ALLOWED_ERR: Raised when the source node is readonly.</p></descr></exception></raises></method><attribute readonly="yes" type="DOMConfiguration" name="domConfig" id="Document3-domConfig" since="DOM Level 3"><descr><p>The configuration used when<code>Document.normalizeDocument()</code>is invoked.</p></descr></attribute><method name="normalizeDocument" id="Document3-normalizeDocument" since="DOM Level 3"><descr><p>This method acts as if the document was going through a save and load cycle, putting the document in a "normal" form. As a consequence, this method updates the replacement tree of<code>EntityReference</code>nodes and normalizes<code>Text</code>nodes, as defined in the method<code>Node.normalize()</code>.</p><p>Otherwise, the actual result depends on the features being set on the<code>Document.domConfig</code>object and governing what operations actually take place. Noticeably this method could also make the document<termref def="dt-namespace-well-formed">namespace well-formed</termref>according to the algorithm described in<specref ref="normalizeDocumentAlgo"/>, check the character normalization, remove the<code>CDATASection</code>nodes, etc. See<code>DOMConfiguration</code>for details.</p><eg role="code" space="preserve">// Keep in the document the information defined // in the XML Information Set (Java example) DOMConfiguration docConfig = myDocument.getDomConfig(); docConfig.setParameter("infoset", Boolean.TRUE); myDocument.normalizeDocument();</eg><p>Mutation events, when supported, are generated to reflect the changes occurring on the document.</p><p>If errors occur during the invocation of this method, such as an attempt to update a<termref def="dt-readonly-node">read-only node</termref>or a<code>Node.nodeName</code>contains an invalid character according to the XML version in use, errors or warnings (<code>DOMError.SEVERITY_ERROR</code>or<code>DOMError.SEVERITY_WARNING</code>) will be reported using the<code>DOMErrorHandler</code>object associated with the "<termref def="parameter-error-handler">error-handler</termref>" parameter. Note this method might also report fatal errors (<code>DOMError.SEVERITY_FATAL_ERROR</code>) if an implementation cannot recover from an error.</p></descr><parameters></parameters><returns type="void"><descr><p/></descr></returns><raises></raises></method><method name="renameNode" id="Document3-renameNode" since="DOM Level 3"><descr><p>Rename an existing node of type<code>ELEMENT_NODE</code>or<code>ATTRIBUTE_NODE</code>.</p><p>When possible this simply changes the name of the given node, otherwise this creates a new node with the specified name and replaces the existing node with the new node as described below.</p><p>If simply changing the name of the given node is not possible, the following operations are performed: a new node is created, any registered event listener is registered on the new node, any user data attached to the old node is removed from that node, the old node is removed from its parent if it has one, the children are moved to the new node, if the renamed node is an<code>Element</code>its attributes are moved to the new node, the new node is inserted at the position the old node used to have in its parent's child nodes list if it has one, the user data that was attached to the old node is attached to the new node.</p><p>When the node being renamed is an<code>Element</code>only the specified attributes are moved, default attributes originated from the DTD are updated according to the new element name. In addition, the implementation may update default attributes from other schemas. Applications should use<code>Document.normalizeDocument()</code>to guarantee these attributes are up-to-date.</p><p>When the node being renamed is an<code>Attr</code>that is attached to an<code>Element</code>, the node is first removed from the<code>Element</code>attributes map. Then, once renamed, either by modifying the existing node or creating a new one as described above, it is put back.</p><p>In addition,</p><ulist><item><p>a user data event<code>NODE_RENAMED</code>is fired,</p></item><item><p>when the implementation supports the feature "MutationNameEvents", each mutation operation involved in this method fires the appropriate event, and in the end the event {<code>http://www.w3.org/2001/xml-events</code>,<code>DOMElementNameChanged</code>} or {<code>http://www.w3.org/2001/xml-events</code>,<code>DOMAttributeNameChanged</code>} is fired.</p></item></ulist></descr><parameters><param name="n" type="Node" attr="in"><descr><p>The node to rename.</p></descr></param><param name="namespaceURI" type="DOMString" attr="in"><descr><p>The new<termref def="dt-namespaceURI">namespace URI</termref>.</p></descr></param><param name="qualifiedName" type="DOMString" attr="in"><descr><p>The new<termref def="dt-qualifiedname">qualified name</termref>.</p></descr></param></parameters><returns type="Node"><descr><p>The renamed node. This is either the specified node or the new node that was created to replace the specified node.</p></descr></returns><raises><exception name="DOMException"><descr><p>NOT_SUPPORTED_ERR: Raised when the type of the specified node is neither<code>ELEMENT_NODE</code>nor<code>ATTRIBUTE_NODE</code>, or if the implementation does not support the renaming of the<termref def="dt-document-element">document element</termref>.</p><p>INVALID_CHARACTER_ERR: Raised if the new qualified name is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p><p>WRONG_DOCUMENT_ERR: Raised when the specified node was created from a different document than this document.</p><p>NAMESPACE_ERR: Raised if the<code>qualifiedName</code>is a malformed<termref def="dt-qualifiedname">qualified name</termref>, if the<code>qualifiedName</code>has a prefix and the<code>namespaceURI</code>is<code>null</code>, or if the<code>qualifiedName</code>has a prefix that is "xml" and the<code>namespaceURI</code>is different from "<loc href="http://www.w3.org/XML/1998/namespace" type="simple" show="replace" actuate="onRequest">http://www.w3.org/XML/1998/namespace</loc>"<bibref ref="Namespaces"/>. Also raised, when the node being renamed is an attribute, if the<code>qualifiedName</code>, or its prefix, is "xmlns" and the<code>namespaceURI</code>is different from "<loc href="http://www.w3.org/2000/xmlns/" type="simple" show="replace" actuate="onRequest">http://www.w3.org/2000/xmlns/</loc>".</p></descr></exception></raises></method></interface>
  <interface name="Node" id="ID-1950641247"><descr><p>The<code>Node</code>interface is the primary datatype for the entire Document Object Model. It represents a single node in the document tree. While all objects implementing the<code>Node</code>interface expose methods for dealing with children, not all objects implementing the<code>Node</code>interface may have children. For example,<code>Text</code>nodes may not have children, and adding children to such nodes results in a<code>DOMException</code>being raised.</p><p>The attributes<code>nodeName</code>,<code>nodeValue</code>and<code>attributes</code>are included as a mechanism to get at node information without casting down to the specific derived interface. In cases where there is no obvious mapping of these attributes for a specific<code>nodeType</code>(e.g.,<code>nodeValue</code>for an<code>Element</code>or<code>attributes</code>for a<code>Comment</code>), this returns<code>null</code>. Note that the specialized interfaces may contain additional and more convenient mechanisms to get and set the relevant information.</p></descr><group id="ID-1841493061" name="NodeType"><descr><p>An integer indicating which type of node this is.</p><note><p>Numeric codes up to 200 are reserved to W3C for possible future use.</p></note></descr><constant id="Node-ELEMENT_NODE" name="ELEMENT_NODE" type="unsigned short" value="1"><descr><p>The node is an<code>Element</code>.</p></descr></constant><constant id="Node-ATTRIBUTE_NODE" name="ATTRIBUTE_NODE" type="unsigned short" value="2"><descr><p>The node is an<code>Attr</code>.</p></descr></constant><constant id="Node-TEXT_NODE" name="TEXT_NODE" type="unsigned short" value="3"><descr><p>The node is a<code>Text</code>node.</p></descr></constant><constant id="Node-CDATA_SECTION_NODE" name="CDATA_SECTION_NODE" type="unsigned short" value="4"><descr><p>The node is a<code>CDATASection</code>.</p></descr></constant><constant id="Node-ENTITY_REFERENCE_NODE" name="ENTITY_REFERENCE_NODE" type="unsigned short" value="5"><descr><p>The node is an<code>EntityReference</code>.</p></descr></constant><constant id="Node-ENTITY_NODE" name="ENTITY_NODE" type="unsigned short" value="6"><descr><p>The node is an<code>Entity</code>.</p></descr></constant><constant id="Node-PROCESSING_INSTRUCTION_NODE" name="PROCESSING_INSTRUCTION_NODE" type="unsigned short" value="7"><descr><p>The node is a<code>ProcessingInstruction</code>.</p></descr></constant><constant id="Node-COMMENT_NODE" name="COMMENT_NODE" type="unsigned short" value="8"><descr><p>The node is a<code>Comment</code>.</p></descr></constant><constant id="Node-DOCUMENT_NODE" name="DOCUMENT_NODE" type="unsigned short" value="9"><descr><p>The node is a<code>Document</code>.</p></descr></constant><constant id="Node-DOCUMENT_TYPE_NODE" name="DOCUMENT_TYPE_NODE" type="unsigned short" value="10"><descr><p>The node is a<code>DocumentType</code>.</p></descr></constant><constant id="Node-DOCUMENT_FRAGMENT_NODE" name="DOCUMENT_FRAGMENT_NODE" type="unsigned short" value="11"><descr><p>The node is a<code>DocumentFragment</code>.</p></descr></constant><constant id="Node-NOTATION_NODE" name="NOTATION_NODE" type="unsigned short" value="12"><descr><p>The node is a<code>Notation</code>.</p></descr></constant></group><p>The values of<code>nodeName</code>,<code>nodeValue</code>, and<code>attributes</code>vary according to the node type as follows:<table cellpadding="3" summary="Layout table: the first cell contains the name of the            interface, the second contains the value of the nodeName attribute            for this interface, the third contains the value of the nodeValue            attribute for this interface and the fourth contains the value of            the attributes attribute for this interface" border="1"><tbody><tr><th rowspan="1" colspan="1">Interface</th><th rowspan="1" colspan="1">nodeName</th><th rowspan="1" colspan="1">nodeValue</th><th rowspan="1" colspan="1">attributes</th></tr><tr><td rowspan="1" colspan="1"><code>Attr</code></td><td rowspan="1" colspan="1">same as<code>Attr.name</code></td><td rowspan="1" colspan="1">same as<code>Attr.value</code></td><td rowspan="1" colspan="1"><code>null</code></td></tr><tr><td rowspan="1" colspan="1"><code>CDATASection</code></td><td rowspan="1" colspan="1"><code>"#cdata-section"</code></td><td rowspan="1" colspan="1">same as<code>CharacterData.data</code>, the content of the CDATA Section</td><td rowspan="1" colspan="1"><code>null</code></td></tr><tr><td rowspan="1" colspan="1"><code>Comment</code></td><td rowspan="1" colspan="1"><code>"#comment"</code></td><td rowspan="1" colspan="1">same as<code>CharacterData.data</code>, the content of the comment</td><td rowspan="1" colspan="1"><code>null</code></td></tr><tr><td rowspan="1" colspan="1"><code>Document</code></td><td rowspan="1" colspan="1"><code>"#document"</code></td><td rowspan="1" colspan="1"><code>null</code></td><td rowspan="1" colspan="1"><code>null</code></td></tr><tr><td rowspan="1" colspan="1"><code>DocumentFragment</code></td><td rowspan="1" colspan="1"><code>"#document-fragment"</code></td><td rowspan="1" colspan="1"><code>null</code></td><td rowspan="1" colspan="1"><code>null</code></td></tr><tr><td rowspan="1" colspan="1"><code>DocumentType</code></td><td rowspan="1" colspan="1">same as<code>DocumentType.name</code></td><td rowspan="1" colspan="1"><code>null</code></td><td rowspan="1" colspan="1"><code>null</code></td></tr><tr><td rowspan="1" colspan="1"><code>Element</code></td><td rowspan="1" colspan="1">same as<code>Element.tagName</code></td><td rowspan="1" colspan="1"><code>null</code></td><td rowspan="1" colspan="1"><code>NamedNodeMap</code></td></tr><tr><td rowspan="1" colspan="1"><code>Entity</code></td><td rowspan="1" colspan="1">entity name</td><td rowspan="1" colspan="1"><code>null</code></td><td rowspan="1" colspan="1"><code>null</code></td></tr><tr><td rowspan="1" colspan="1"><code>EntityReference</code></td><td rowspan="1" colspan="1">name of entity referenced</td><td rowspan="1" colspan="1"><code>null</code></td><td rowspan="1" colspan="1"><code>null</code></td></tr><tr><td rowspan="1" colspan="1"><code>Notation</code></td><td rowspan="1" colspan="1">notation name</td><td rowspan="1" colspan="1"><code>null</code></td><td rowspan="1" colspan="1"><code>null</code></td></tr><tr><td rowspan="1" colspan="1"><code>ProcessingInstruction</code></td><td rowspan="1" colspan="1">same as<code>ProcessingInstruction.target</code></td><td rowspan="1" colspan="1">same as<code>ProcessingInstruction.data</code></td><td rowspan="1" colspan="1"><code>null</code></td></tr><tr><td rowspan="1" colspan="1"><code>Text</code></td><td rowspan="1" colspan="1"><code>"#text"</code></td><td rowspan="1" colspan="1">same as<code>CharacterData.data</code>, the content of the text node</td><td rowspan="1" colspan="1"><code>null</code></td></tr></tbody></table></p><attribute type="DOMString" readonly="yes" name="nodeName" id="ID-F68D095"><descr><p>The name of this node, depending on its type; see the table above.</p></descr></attribute><attribute type="DOMString" name="nodeValue" id="ID-F68D080" readonly="no"><descr><p>The value of this node, depending on its type; see the table above. When it is defined to be<code>null</code>, setting it has no effect, including if the node is<termref def="dt-readonly-node">read-only</termref>.</p></descr><setraises><exception name="DOMException"><descr><p>NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly and if it is not defined to be<code>null</code>.</p></descr></exception></setraises><getraises><exception name="DOMException"><descr><p>DOMSTRING_SIZE_ERR: Raised when it would return more characters than fit in a<code>DOMString</code>variable on the implementation platform.</p></descr></exception></getraises></attribute><attribute type="unsigned short" name="nodeType" readonly="yes" id="ID-111237558"><descr><p>A code representing the type of the underlying object, as defined above.</p></descr></attribute><attribute type="Node" readonly="yes" name="parentNode" id="ID-1060184317"><descr><p>The<termref def="dt-parent">parent</termref>of this node. All nodes, except<code>Attr</code>,<code>Document</code>,<code>DocumentFragment</code>,<code>Entity</code>, and<code>Notation</code>may have a parent. However, if a node has just been created and not yet added to the tree, or if it has been removed from the tree, this is<code>null</code>.</p></descr></attribute><attribute type="NodeList" readonly="yes" name="childNodes" id="ID-1451460987"><descr><p>A<code>NodeList</code>that contains all children of this node. If there are no children, this is a<code>NodeList</code>containing no nodes.</p></descr></attribute><attribute readonly="yes" type="Node" name="firstChild" id="ID-169727388"><descr><p>The first child of this node. If there is no such node, this returns<code>null</code>.</p></descr></attribute><attribute readonly="yes" type="Node" name="lastChild" id="ID-61AD09FB"><descr><p>The last child of this node. If there is no such node, this returns<code>null</code>.</p></descr></attribute><attribute readonly="yes" type="Node" name="previousSibling" id="ID-640FB3C8"><descr><p>The node immediately preceding this node. If there is no such node, this returns<code>null</code>.</p></descr></attribute><attribute readonly="yes" type="Node" name="nextSibling" id="ID-6AC54C2F"><descr><p>The node immediately following this node. If there is no such node, this returns<code>null</code>.</p></descr></attribute><attribute readonly="yes" type="NamedNodeMap" name="attributes" id="ID-84CF096"><descr><p>A<code>NamedNodeMap</code>containing the attributes of this node (if it is an<code>Element</code>) or<code>null</code>otherwise.</p></descr></attribute><attribute readonly="yes" type="Document" name="ownerDocument" id="node-ownerDoc" version="DOM Level 2"><descr><p>The<code>Document</code>object associated with this node. This is also the<code>Document</code>object used to create new nodes. When this node is a<code>Document</code>or a<code>DocumentType</code>which is not used with any<code>Document</code>yet, this is<code>null</code>.</p></descr></attribute><method name="insertBefore" id="ID-952280727" version="DOM Level 3"><descr><p>Inserts the node<code>newChild</code>before the existing child node<code>refChild</code>. If<code>refChild</code>is<code>null</code>, insert<code>newChild</code>at the end of the list of children.</p><p>If<code>newChild</code>is a<code>DocumentFragment</code>object, all of its children are inserted, in the same order, before<code>refChild</code>. If the<code>newChild</code>is already in the tree, it is first removed.</p><note><p>Inserting a node before itself is implementation dependent.</p></note></descr><parameters><param name="newChild" type="Node" attr="in"><descr><p>The node to insert.</p></descr></param><param name="refChild" type="Node" attr="in"><descr><p>The reference node, i.e., the node before which the new node must be inserted.</p></descr></param></parameters><returns type="Node"><descr><p>The node being inserted.</p></descr></returns><raises><exception name="DOMException"><descr><p>HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not allow children of the type of the<code>newChild</code>node, or if the node to insert is one of this node's<termref def="dt-ancestor">ancestors</termref>or this node itself, or if this node is of type<code>Document</code>and the DOM application attempts to insert a second<code>DocumentType</code>or<code>Element</code>node.</p><p>WRONG_DOCUMENT_ERR: Raised if<code>newChild</code>was created from a different document than the one that created this node.</p><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly or if the parent of the node being inserted is readonly.</p><p>NOT_FOUND_ERR: Raised if<code>refChild</code>is not a child of this node.</p><p>NOT_SUPPORTED_ERR: if this node is of type<code>Document</code>, this exception might be raised if the DOM implementation doesn't support the insertion of a<code>DocumentType</code>or<code>Element</code>node.</p></descr></exception></raises></method><method name="replaceChild" id="ID-785887307" version="DOM Level 3"><descr><p>Replaces the child node<code>oldChild</code>with<code>newChild</code>in the list of children, and returns the<code>oldChild</code>node.</p><p>If<code>newChild</code>is a<code>DocumentFragment</code>object,<code>oldChild</code>is replaced by all of the<code>DocumentFragment</code>children, which are inserted in the same order. If the<code>newChild</code>is already in the tree, it is first removed.</p><note><p>Replacing a node with itself is implementation dependent.</p></note></descr><parameters><param name="newChild" type="Node" attr="in"><descr><p>The new node to put in the child list.</p></descr></param><param name="oldChild" type="Node" attr="in"><descr><p>The node being replaced in the list.</p></descr></param></parameters><returns type="Node"><descr><p>The node replaced.</p></descr></returns><raises><exception name="DOMException"><descr><p>HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not allow children of the type of the<code>newChild</code>node, or if the node to put in is one of this node's<termref def="dt-ancestor">ancestors</termref>or this node itself, or if this node is of type<code>Document</code>and the result of the replacement operation would add a second<code>DocumentType</code>or<code>Element</code>on the<code>Document</code>node.</p><p>WRONG_DOCUMENT_ERR: Raised if<code>newChild</code>was created from a different document than the one that created this node.</p><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node or the parent of the new node is readonly.</p><p>NOT_FOUND_ERR: Raised if<code>oldChild</code>is not a child of this node.</p><p>NOT_SUPPORTED_ERR: if this node is of type<code>Document</code>, this exception might be raised if the DOM implementation doesn't support the replacement of the<code>DocumentType</code>child or<code>Element</code>child.</p></descr></exception></raises></method><method name="removeChild" id="ID-1734834066" version="DOM Level 3"><descr><p>Removes the child node indicated by<code>oldChild</code>from the list of children, and returns it.</p></descr><parameters><param name="oldChild" type="Node" attr="in"><descr><p>The node being removed.</p></descr></param></parameters><returns type="Node"><descr><p>The node removed.</p></descr></returns><raises><exception name="DOMException"><descr><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p><p>NOT_FOUND_ERR: Raised if<code>oldChild</code>is not a child of this node.</p><p>NOT_SUPPORTED_ERR: if this node is of type<code>Document</code>, this exception might be raised if the DOM implementation doesn't support the removal of the<code>DocumentType</code>child or the<code>Element</code>child.</p></descr></exception></raises></method><method name="appendChild" id="ID-184E7107" version="DOM Level 3"><descr><p>Adds the node<code>newChild</code>to the end of the list of children of this node. If the<code>newChild</code>is already in the tree, it is first removed.</p></descr><parameters><param name="newChild" type="Node" attr="in"><descr><p>The node to add.</p><p>If it is a<code>DocumentFragment</code>object, the entire contents of the document fragment are moved into the child list of this node</p></descr></param></parameters><returns type="Node"><descr><p>The node added.</p></descr></returns><raises><exception name="DOMException"><descr><p>HIERARCHY_REQUEST_ERR: Raised if this node is of a type that does not allow children of the type of the<code>newChild</code>node, or if the node to append is one of this node's<termref def="dt-ancestor">ancestors</termref>or this node itself, or if this node is of type<code>Document</code>and the DOM application attempts to append a second<code>DocumentType</code>or<code>Element</code>node.</p><p>WRONG_DOCUMENT_ERR: Raised if<code>newChild</code>was created from a different document than the one that created this node.</p><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly or if the previous parent of the node being inserted is readonly.</p><p>NOT_SUPPORTED_ERR: if the<code>newChild</code>node is a child of the<code>Document</code>node, this exception might be raised if the DOM implementation doesn't support the removal of the<code>DocumentType</code>child or<code>Element</code>child.</p></descr></exception></raises></method><method name="hasChildNodes" id="ID-810594187"><descr><p>Returns whether this node has any children.</p></descr><parameters></parameters><returns type="boolean"><descr><p>Returns<code>true</code>if this node has any children,<code>false</code>otherwise.</p></descr></returns><raises></raises></method><method name="cloneNode" id="ID-3A0ED0A4"><descr><p>Returns a duplicate of this node, i.e., serves as a generic copy constructor for nodes. The duplicate node has no parent (<code>parentNode</code>is<code>null</code>) and no user data. User data associated to the imported node is not carried over. However, if any<code>UserDataHandlers</code>has been specified along with the associated data these handlers will be called with the appropriate parameters before this method returns.</p><p>Cloning an<code>Element</code>copies all attributes and their values, including those generated by the XML processor to represent defaulted attributes, but this method does not copy any children it contains unless it is a deep clone. This includes text contained in an the<code>Element</code>since the text is contained in a child<code>Text</code>node. Cloning an<code>Attr</code>directly, as opposed to be cloned as part of an<code>Element</code>cloning operation, returns a specified attribute (<code>specified</code>is<code>true</code>). Cloning an<code>Attr</code>always clones its children, since they represent its value, no matter whether this is a deep clone or not. Cloning an<code>EntityReference</code>automatically constructs its subtree if a corresponding<code>Entity</code>is available, no matter whether this is a deep clone or not. Cloning any other type of node simply returns a copy of this node.</p><p>Note that cloning an immutable subtree results in a mutable copy, but the children of an<code>EntityReference</code>clone are<termref def="dt-readonly-node">readonly</termref>. In addition, clones of unspecified<code>Attr</code>nodes are specified. And, cloning<code>Document</code>,<code>DocumentType</code>,<code>Entity</code>, and<code>Notation</code>nodes is implementation dependent.</p></descr><parameters><param name="deep" type="boolean" attr="in"><descr><p>If<code>true</code>, recursively clone the subtree under the specified node; if<code>false</code>, clone only the node itself (and its attributes, if it is an<code>Element</code>).</p></descr></param></parameters><returns type="Node"><descr><p>The duplicate node.</p></descr></returns><raises></raises></method><method id="ID-normalize" name="normalize" version="DOM Level 3"><descr><p>Puts all<code>Text</code>nodes in the full depth of the sub-tree underneath this<code>Node</code>, including attribute nodes, into a "normal" form where only structure (e.g., elements, comments, processing instructions, CDATA sections, and entity references) separates<code>Text</code>nodes, i.e., there are neither adjacent<code>Text</code>nodes nor empty<code>Text</code>nodes. This can be used to ensure that the DOM view of a document is the same as if it were saved and re-loaded, and is useful when operations (such as XPointer<bibref role="informative" ref="XPointer"/>lookups) that depend on a particular document tree structure are to be used. If the parameter "<termref def="parameter-normalize-characters">normalize-characters</termref>" of the<code>DOMConfiguration</code>object attached to the<code>Node.ownerDocument</code>is<code>true</code>, this method will also fully normalize the characters of the<code>Text</code>nodes.</p><note><p>In cases where the document contains<code>CDATASections</code>, the normalize operation alone may not be sufficient, since XPointers do not differentiate between<code>Text</code>nodes and<code>CDATASection</code>nodes.</p></note></descr><parameters></parameters><returns type="void"><descr><p/></descr></returns><raises></raises></method><method name="isSupported" id="Level-2-Core-Node-supports" since="DOM Level 2"><descr><p>Tests whether the DOM implementation implements a specific feature and that feature is supported by this node, as specified in<specref ref="DOMFeatures"/>.</p></descr><parameters><param name="feature" type="DOMString" attr="in"><descr><p>The name of the feature to test.</p></descr></param><param name="version" type="DOMString" attr="in"><descr><p>This is the version number of the feature to test.</p></descr></param></parameters><returns type="boolean"><descr><p>Returns<code>true</code>if the specified feature is supported on this node,<code>false</code>otherwise.</p></descr></returns><raises></raises></method><attribute readonly="yes" type="DOMString" name="namespaceURI" id="ID-NodeNSname" since="DOM Level 2"><descr><p>The<termref def="dt-namespaceURI">namespace URI</termref>of this node, or<code>null</code>if it is unspecified (see<specref ref="Namespaces-Considerations"/>).</p><p>This is not a computed value that is the result of a namespace lookup based on an examination of the namespace declarations in scope. It is merely the namespace URI given at creation time.</p><p>For nodes of any type other than<code>ELEMENT_NODE</code>and<code>ATTRIBUTE_NODE</code>and nodes created with a DOM Level 1 method, such as<code>Document.createElement()</code>, this is always<code>null</code>.</p><note><p>Per the<emph>Namespaces in XML</emph>Specification<bibref ref="Namespaces"/>an attribute does not inherit its namespace from the element it is attached to. If an attribute is not explicitly given a namespace, it simply has no namespace.</p></note></descr></attribute><attribute type="DOMString" name="prefix" id="ID-NodeNSPrefix" since="DOM Level 2" readonly="no"><descr><p>The<termref def="dt-namespaceprefix">namespace prefix</termref>of this node, or<code>null</code>if it is unspecified. When it is defined to be<code>null</code>, setting it has no effect, including if the node is<termref def="dt-readonly-node">read-only</termref>.</p><p>Note that setting this attribute, when permitted, changes the<code>nodeName</code>attribute, which holds the<termref def="dt-qualifiedname">qualified name</termref>, as well as the<code>tagName</code>and<code>name</code>attributes of the<code>Element</code>and<code>Attr</code>interfaces, when applicable.</p><p>Setting the prefix to<code>null</code>makes it unspecified, setting it to an empty string is implementation dependent.</p><p>Note also that changing the prefix of an attribute that is known to have a default value, does not make a new attribute with the default value and the original prefix appear, since the<code>namespaceURI</code>and<code>localName</code>do not change.</p><p>For nodes of any type other than<code>ELEMENT_NODE</code>and<code>ATTRIBUTE_NODE</code>and nodes created with a DOM Level 1 method, such as<code>createElement</code>from the<code>Document</code>interface, this is always<code>null</code>.</p></descr><setraises><exception name="DOMException"><descr><p>INVALID_CHARACTER_ERR: Raised if the specified prefix contains an illegal character according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p><p>NAMESPACE_ERR: Raised if the specified<code>prefix</code>is malformed per the Namespaces in XML specification, if the<code>namespaceURI</code>of this node is<code>null</code>, if the specified prefix is "xml" and the<code>namespaceURI</code>of this node is different from "<loc href="http://www.w3.org/XML/1998/namespace" type="simple" show="replace" actuate="onRequest">http://www.w3.org/XML/1998/namespace</loc>", if this node is an attribute and the specified prefix is "xmlns" and the<code>namespaceURI</code>of this node is different from "<loc href="http://www.w3.org/2000/xmlns/" type="simple" show="replace" actuate="onRequest">http://www.w3.org/2000/xmlns/</loc>", or if this node is an attribute and the<code>qualifiedName</code>of this node is "xmlns"<bibref ref="Namespaces"/>.</p></descr></exception></setraises></attribute><attribute readonly="yes" type="DOMString" name="localName" id="ID-NodeNSLocalN" since="DOM Level 2"><descr><p>Returns the local part of the<termref def="dt-qualifiedname">qualified name</termref>of this node.</p><p>For nodes of any type other than<code>ELEMENT_NODE</code>and<code>ATTRIBUTE_NODE</code>and nodes created with a DOM Level 1 method, such as<code>Document.createElement()</code>, this is always<code>null</code>.</p></descr></attribute><method name="hasAttributes" id="ID-NodeHasAttrs" since="DOM Level 2"><descr><p>Returns whether this node (if it is an element) has any attributes.</p></descr><parameters></parameters><returns type="boolean"><descr><p>Returns<code>true</code>if this node has any attributes,<code>false</code>otherwise.</p></descr></returns><raises></raises></method><attribute readonly="yes" type="DOMString" name="baseURI" id="Node3-baseURI" since="DOM Level 3"><descr><p>The absolute base URI of this node or<code>null</code>if the implementation wasn't able to obtain an absolute URI. This value is computed as described in<specref ref="baseURIs-Considerations"/>. However, when the<code>Document</code>supports the feature "HTML"<bibref role="informative" ref="DOM2HTML"/>, the base URI is computed using first the value of the href attribute of the HTML BASE element if any, and the value of the<code>documentURI</code>attribute from the<code>Document</code>interface otherwise.</p></descr></attribute><group id="DocumentPosition" name="DocumentPosition" since="DOM Level 3"><descr><p>A bitmask indicating the relative document position of a node with respect to another node.</p><p>If the two nodes being compared are the same node, then no flags are set on the return.</p><p>Otherwise, the order of two nodes is determined by looking for common containers -- containers which contain both. A node directly contains any child nodes. A node also directly contains any other nodes attached to it such as attributes contained in an element or entities and notations contained in a document type. Nodes contained in contained nodes are also contained, but less-directly as the number of intervening containers increases.</p><p>If there is no common container node, then the order is based upon order between the root container of each node that is in no container. In this case, the result is disconnected and implementation-specific. This result is stable as long as these outer-most containing nodes remain in memory and are not inserted into some other containing node. This would be the case when the nodes belong to different documents or fragments, and cloning the document or inserting a fragment might change the order.</p><p>If one of the nodes being compared contains the other node, then the container precedes the contained node, and reversely the contained node follows the container. For example, when comparing an element against its own attribute or child, the element node precedes its attribute node and its child node, which both follow it.</p><p>If neither of the previous cases apply, then there exists a most-direct container common to both nodes being compared. In this case, the order is determined based upon the two determining nodes directly contained in this most-direct common container that either are or contain the corresponding nodes being compared.</p><p>If these two determining nodes are both child nodes, then the natural DOM order of these determining nodes within the containing node is returned as the order of the corresponding nodes. This would be the case, for example, when comparing two child elements of the same element.</p><p>If one of the two determining nodes is a child node and the other is not, then the corresponding node of the child node follows the corresponding node of the non-child node. This would be the case, for example, when comparing an attribute of an element with a child element of the same element.</p><p>If neither of the two determining node is a child node and one determining node has a greater value of<code>nodeType</code>than the other, then the corresponding node precedes the other. This would be the case, for example, when comparing an entity of a document type against a notation of the same document type.</p><p>If neither of the two determining node is a child node and<code>nodeType</code>is the same for both determining nodes, then an implementation-dependent order between the determining nodes is returned. This order is stable as long as no nodes of the same nodeType are inserted into or removed from the direct container. This would be the case, for example, when comparing two attributes of the same element, and inserting or removing additional attributes might change the order between existing attributes.</p></descr><constant id="Node-DOCUMENT_POSITION_DISCONNECTED" name="DOCUMENT_POSITION_DISCONNECTED" type="unsigned short" value="0x01"><descr><p>The two nodes are disconnected. Order between disconnected nodes is always implementation-specific.</p></descr></constant><constant id="Node-DOCUMENT_POSITION_PRECEDING" name="DOCUMENT_POSITION_PRECEDING" type="unsigned short" value="0x02"><descr><p>The second node precedes the reference node.</p></descr></constant><constant id="Node-DOCUMENT_POSITION_FOLLOWING" name="DOCUMENT_POSITION_FOLLOWING" type="unsigned short" value="0x04"><descr><p>The node follows the reference node.</p></descr></constant><constant id="Node-DOCUMENT_POSITION_CONTAINS" name="DOCUMENT_POSITION_CONTAINS" type="unsigned short" value="0x08"><descr><p>The node contains the reference node. A node which contains is always preceding, too.</p></descr></constant><constant id="Node-DOCUMENT_POSITION_CONTAINED_BY" name="DOCUMENT_POSITION_CONTAINED_BY" type="unsigned short" value="0x10"><descr><p>The node is contained by the reference node. A node which is contained is always following, too.</p></descr></constant><constant id="Node-DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC" name="DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC" type="unsigned short" value="0x20"><descr><p>The determination of preceding versus following is implementation-specific.</p></descr></constant></group><method name="compareDocumentPosition" id="Node3-compareDocumentPosition" since="DOM Level 3"><descr><p>Compares the reference node, i.e. the node on which this method is being called, with a node, i.e. the one passed as a parameter, with regard to their position in the document and according to the<termref def="dt-document-order">document order</termref>.</p></descr><parameters><param attr="in" type="Node" name="other"><descr><p>The node to compare against the reference node.</p></descr></param></parameters><returns type="unsigned short"><descr><p>Returns how the node is positioned relatively to the reference node.</p></descr></returns><raises><exception name="DOMException"><descr><p>NOT_SUPPORTED_ERR: when the compared nodes are from different DOM implementations that do not coordinate to return consistent implementation-specific results.</p></descr></exception></raises></method><attribute name="textContent" id="Node3-textContent" type="DOMString" readonly="no" since="DOM Level 3"><descr><p>This attribute returns the text content of this node and its descendants. When it is defined to be<code>null</code>, setting it has no effect. On setting, any possible children this node may have are removed and, if it the new string is not empty or<code>null</code>, replaced by a single<code>Text</code>node containing the string this attribute is set to.</p><p>On getting, no serialization is performed, the returned string does not contain any markup. No whitespace normalization is performed and the returned string does not contain the white spaces in element content (see the attribute<code>Text.isElementContentWhitespace</code>). Similarly, on setting, no parsing is performed either, the input string is taken as pure textual content.</p><p>The string returned is made of the text content of this node depending on its type, as defined below:</p><table cellpadding="3" summary="The string returned is made of the text content of the                node. The first cell of this table contains the type of the                Node, the second cell indicates the string returned by                textContent." border="1"><tbody><tr><th rowspan="1" colspan="1">Node type</th><th rowspan="1" colspan="1">Content</th></tr><tr><td rowspan="1" colspan="1">ELEMENT_NODE, ATTRIBUTE_NODE, ENTITY_NODE, ENTITY_REFERENCE_NODE, DOCUMENT_FRAGMENT_NODE</td><td rowspan="1" colspan="1">concatenation of the<code>textContent</code>attribute value of every child node, excluding COMMENT_NODE and PROCESSING_INSTRUCTION_NODE nodes. This is the empty string if the node has no children.</td></tr><tr><td rowspan="1" colspan="1">TEXT_NODE, CDATA_SECTION_NODE, COMMENT_NODE, PROCESSING_INSTRUCTION_NODE</td><td rowspan="1" colspan="1"><code>nodeValue</code></td></tr><tr><td rowspan="1" colspan="1">DOCUMENT_NODE, DOCUMENT_TYPE_NODE, NOTATION_NODE</td><td rowspan="1" colspan="1"><emph>null</emph></td></tr></tbody></table></descr><setraises><exception name="DOMException"><descr><p>NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.</p></descr></exception></setraises><getraises><exception name="DOMException"><descr><p>DOMSTRING_SIZE_ERR: Raised when it would return more characters than fit in a<code>DOMString</code>variable on the implementation platform.</p></descr></exception></getraises></attribute><method name="isSameNode" id="Node3-isSameNode" since="DOM Level 3"><descr><p>Returns whether this node is the same node as the given one.</p><p>This method provides a way to determine whether two<code>Node</code>references returned by the implementation reference the same object. When two<code>Node</code>references are references to the same object, even if through a proxy, the references may be used completely interchangeably, such that all attributes have the same values and calling the same DOM method on either reference always has exactly the same effect.</p></descr><parameters><param attr="in" type="Node" name="other"><descr><p>The node to test against.</p></descr></param></parameters><returns type="boolean"><descr><p>Returns<code>true</code>if the nodes are the same,<code>false</code>otherwise.</p></descr></returns><raises></raises></method><method name="lookupPrefix" id="Node3-lookupNamespacePrefix" since="DOM Level 3"><descr><p>Look up the prefix associated to the given namespace URI, starting from this node. The default namespace declarations are ignored by this method.</p><p>See<specref ref="lookupNamespacePrefixAlgo"/>for details on the algorithm used by this method.</p></descr><parameters><param attr="in" type="DOMString" name="namespaceURI"><descr><p>The namespace URI to look for.</p></descr></param></parameters><returns type="DOMString"><descr><p>Returns an associated namespace prefix if found or<code>null</code>if none is found. If more than one prefix are associated to the namespace prefix, the returned namespace prefix is implementation dependent.</p></descr></returns><raises></raises></method><method name="isDefaultNamespace" id="Node3-isDefaultNamespace" since="DOM Level 3"><descr><p>This method checks if the specified<code>namespaceURI</code>is the default namespace or not.</p></descr><parameters><param name="namespaceURI" type="DOMString" attr="in"><descr><p>The namespace URI to look for.</p></descr></param></parameters><returns type="boolean"><descr><p>Returns<code>true</code>if the specified<code>namespaceURI</code>is the default namespace,<code>false</code>otherwise.</p></descr></returns><raises></raises></method><method name="lookupNamespaceURI" id="Node3-lookupNamespaceURI" since="DOM Level 3"><descr><p>Look up the namespace URI associated to the given prefix, starting from this node.</p><p>See<specref ref="lookupNamespaceURIAlgo"/>for details on the algorithm used by this method.</p></descr><parameters><param attr="in" type="DOMString" name="prefix"><descr><p>The prefix to look for. If this parameter is<code>null</code>, the method will return the default namespace URI if any.</p></descr></param></parameters><returns type="DOMString"><descr><p>Returns the associated namespace URI or<code>null</code>if none is found.</p></descr></returns><raises></raises></method><method name="isEqualNode" id="Node3-isEqualNode" since="DOM Level 3"><descr><p>Tests whether two nodes are equal.</p><p>This method tests for equality of nodes, not sameness (i.e., whether the two nodes are references to the same object) which can be tested with<code>Node.isSameNode()</code>. All nodes that are the same will also be equal, though the reverse may not be true.</p><p>Two nodes are equal if and only if the following conditions are satisfied:<ulist><item><p>The two nodes are of the same type.</p></item><item><p>The following string attributes are equal:<code>nodeName</code>,<code>localName</code>,<code>namespaceURI</code>,<code>prefix</code>,<code>nodeValue</code>. This is: they are both<code>null</code>, or they have the same length and are character for character identical.</p></item><item><p>The<code>attributes</code><code>NamedNodeMaps</code>are equal. This is: they are both<code>null</code>, or they have the same length and for each node that exists in one map there is a node that exists in the other map and is equal, although not necessarily at the same index.</p></item><item><p>The<code>childNodes</code><code>NodeLists</code>are equal. This is: they are both<code>null</code>, or they have the same length and contain equal nodes at the same index. Note that normalization can affect equality; to avoid this, nodes should be normalized before being compared.</p></item></ulist></p><p>For two<code>DocumentType</code>nodes to be equal, the following conditions must also be satisfied:<ulist><item><p>The following string attributes are equal:<code>publicId</code>,<code>systemId</code>,<code>internalSubset</code>.</p></item><item><p>The<code>entities</code><code>NamedNodeMaps</code>are equal.</p></item><item><p>The<code>notations</code><code>NamedNodeMaps</code>are equal.</p></item></ulist></p><p>On the other hand, the following do not affect equality: the<code>ownerDocument</code>,<code>baseURI</code>, and<code>parentNode</code>attributes, the<code>specified</code>attribute for<code>Attr</code>nodes, the<code>schemaTypeInfo</code>attribute for<code>Attr</code>and<code>Element</code>nodes, the<code>Text.isElementContentWhitespace</code>attribute for<code>Text</code>nodes, as well as any user data or event listeners registered on the nodes.</p><note><p>As a general rule, anything not mentioned in the description above is not significant in consideration of equality checking. Note that future versions of this specification may take into account more attributes and implementations conform to this specification are expected to be updated accordingly.</p></note></descr><parameters><param name="arg" type="Node" attr="in"><descr><p>The node to compare equality with.</p></descr></param></parameters><returns type="boolean"><descr><p>Returns<code>true</code>if the nodes are equal,<code>false</code>otherwise.</p></descr></returns><raises></raises></method><method name="getFeature" id="Node3-getFeature" since="DOM Level 3"><descr><p>This method returns a specialized object which implements the specialized APIs of the specified feature and version, as specified in<specref ref="DOMFeatures"/>. The specialized object may also be obtained by using binding-specific casting methods but is not necessarily expected to, as discussed in<specref ref="Embedded-DOM"/>. This method also allow the implementation to provide specialized objects which do not support the<code>Node</code>interface.</p></descr><parameters><param name="feature" type="DOMString" attr="in"><descr><p>The name of the feature requested. Note that any plus sign "+" prepended to the name of the feature will be ignored since it is not significant in the context of this method.</p></descr></param><param name="version" type="DOMString" attr="in"><descr><p>This is the version number of the feature to test.</p></descr></param></parameters><returns type="DOMObject"><descr><p>Returns an object which implements the specialized APIs of the specified feature and version, if any, or<code>null</code>if there is no object which implements interfaces associated with that feature. If the<code>DOMObject</code>returned by this method implements the<code>Node</code>interface, it must delegate to the primary core<code>Node</code>and not return results inconsistent with the primary core<code>Node</code>such as attributes, childNodes, etc.</p></descr></returns><raises></raises></method><method name="setUserData" id="Node3-setUserData" since="DOM Level 3"><descr><p>Associate an object to a key on this node. The object can later be retrieved from this node by calling<code>getUserData</code>with the same key.</p></descr><parameters><param name="key" type="DOMString" attr="in"><descr><p>The key to associate the object to.</p></descr></param><param name="data" type="DOMUserData" attr="in"><descr><p>The object to associate to the given key, or<code>null</code>to remove any existing association to that key.</p></descr></param><param name="handler" type="UserDataHandler" attr="in"><descr><p>The handler to associate to that key, or<code>null</code>.</p></descr></param></parameters><returns type="DOMUserData"><descr><p>Returns the<code>DOMUserData</code>previously associated to the given key on this node, or<code>null</code>if there was none.</p></descr></returns><raises></raises></method><method name="getUserData" id="Node3-getUserData" since="DOM Level 3"><descr><p>Retrieves the object associated to a key on a this node. The object must first have been set to this node by calling<code>setUserData</code>with the same key.</p></descr><parameters><param name="key" type="DOMString" attr="in"><descr><p>The key the object is associated to.</p></descr></param></parameters><returns type="DOMUserData"><descr><p>Returns the<code>DOMUserData</code>associated to the given key on this node, or<code>null</code>if there was none.</p></descr></returns><raises></raises></method></interface>
  <interface name="NodeList" id="ID-536297177"><descr><p>The<code>NodeList</code>interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented.<code>NodeList</code>objects in the DOM are<termref def="td-live">live</termref>.</p><p>The items in the<code>NodeList</code>are accessible via an integral index, starting from 0.</p></descr><method name="item" id="ID-844377136"><descr><p>Returns the<code>index</code>th item in the collection. If<code>index</code>is greater than or equal to the number of nodes in the list, this returns<code>null</code>.</p></descr><parameters><param name="index" type="unsigned long" attr="in"><descr><p>Index into the collection.</p></descr></param></parameters><returns type="Node"><descr><p>The node at the<code>index</code>th position in the<code>NodeList</code>, or<code>null</code>if that is not a valid index.</p></descr></returns><raises></raises></method><attribute type="unsigned long" readonly="yes" name="length" id="ID-203510337"><descr><p>The number of nodes in the list. The range of valid child node indices is 0 to<code>length-1</code>inclusive.</p></descr></attribute></interface>
  <interface name="NamedNodeMap" id="ID-1780488922"><descr><p>Objects implementing the<code>NamedNodeMap</code>interface are used to represent collections of nodes that can be accessed by name. Note that<code>NamedNodeMap</code>does not inherit from<code>NodeList</code>;<code>NamedNodeMaps</code>are not maintained in any particular order. Objects contained in an object implementing<code>NamedNodeMap</code>may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a<code>NamedNodeMap</code>, and does not imply that the DOM specifies an order to these Nodes.</p><p><code>NamedNodeMap</code>objects in the DOM are<termref def="td-live">live</termref>.</p></descr><method name="getNamedItem" id="ID-1074577549"><descr><p>Retrieves a node specified by name.</p></descr><parameters><param name="name" type="DOMString" attr="in"><descr><p>The<code>nodeName</code>of a node to retrieve.</p></descr></param></parameters><returns type="Node"><descr><p>A<code>Node</code>(of any type) with the specified<code>nodeName</code>, or<code>null</code>if it does not identify any node in this map.</p></descr></returns><raises></raises></method><method name="setNamedItem" id="ID-1025163788"><descr><p>Adds a node using its<code>nodeName</code>attribute. If a node with that name is already present in this map, it is replaced by the new one. Replacing a node by itself has no effect.</p><p>As the<code>nodeName</code>attribute is used to derive the name which the node must be stored under, multiple nodes of certain types (those that have a "special" string value) cannot be stored as the names would clash. This is seen as preferable to allowing nodes to be aliased.</p></descr><parameters><param name="arg" type="Node" attr="in"><descr><p>A node to store in this map. The node will later be accessible using the value of its<code>nodeName</code>attribute.</p></descr></param></parameters><returns type="Node"><descr><p>If the new<code>Node</code>replaces an existing node the replaced<code>Node</code>is returned, otherwise<code>null</code>is returned.</p></descr></returns><raises><exception name="DOMException"><descr><p>WRONG_DOCUMENT_ERR: Raised if<code>arg</code>was created from a different document than the one that created this map.</p><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this map is readonly.</p><p>INUSE_ATTRIBUTE_ERR: Raised if<code>arg</code>is an<code>Attr</code>that is already an attribute of another<code>Element</code>object. The DOM user must explicitly clone<code>Attr</code>nodes to re-use them in other elements.</p><p>HIERARCHY_REQUEST_ERR: Raised if an attempt is made to add a node doesn't belong in this NamedNodeMap. Examples would include trying to insert something other than an Attr node into an Element's map of attributes, or a non-Entity node into the DocumentType's map of Entities.</p></descr></exception></raises></method><method name="removeNamedItem" id="ID-D58B193"><descr><p>Removes a node specified by name. When this map contains the attributes attached to an element, if the removed attribute is known to have a default value, an attribute immediately appears containing the default value as well as the corresponding namespace URI, local name, and prefix when applicable.</p></descr><parameters><param name="name" type="DOMString" attr="in"><descr><p>The<code>nodeName</code>of the node to remove.</p></descr></param></parameters><returns type="Node"><descr><p>The node removed from this map if a node with such a name exists.</p></descr></returns><raises><exception name="DOMException"><descr><p>NOT_FOUND_ERR: Raised if there is no node named<code>name</code>in this map.</p><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this map is readonly.</p></descr></exception></raises></method><method name="item" id="ID-349467F9"><descr><p>Returns the<code>index</code>th item in the map. If<code>index</code>is greater than or equal to the number of nodes in this map, this returns<code>null</code>.</p></descr><parameters><param name="index" type="unsigned long" attr="in"><descr><p>Index into this map.</p></descr></param></parameters><returns type="Node"><descr><p>The node at the<code>index</code>th position in the map, or<code>null</code>if that is not a valid index.</p></descr></returns><raises></raises></method><attribute type="unsigned long" readonly="yes" name="length" id="ID-6D0FB19E"><descr><p>The number of nodes in this map. The range of valid child node indices is<code>0</code>to<code>length-1</code>inclusive.</p></descr></attribute><method name="getNamedItemNS" id="ID-getNamedItemNS" since="DOM Level 2"><descr><p>Retrieves a node specified by local name and namespace URI.</p><p>Per<bibref ref="Namespaces"/>, applications must use the value null as the namespaceURI parameter for methods if they wish to have no namespace.</p></descr><parameters><param name="namespaceURI" type="DOMString" attr="in"><descr><p>The<termref def="dt-namespaceURI">namespace URI</termref>of the node to retrieve.</p></descr></param><param name="localName" type="DOMString" attr="in"><descr><p>The<termref def="dt-localname">local name</termref>of the node to retrieve.</p></descr></param></parameters><returns type="Node"><descr><p>A<code>Node</code>(of any type) with the specified local name and namespace URI, or<code>null</code>if they do not identify any node in this map.</p></descr></returns><raises><exception name="DOMException"><descr><p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature "XML" and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p></descr></exception></raises></method><method name="setNamedItemNS" id="ID-setNamedItemNS" since="DOM Level 2"><descr><p>Adds a node using its<code>namespaceURI</code>and<code>localName</code>. If a node with that namespace URI and that local name is already present in this map, it is replaced by the new one. Replacing a node by itself has no effect.</p><p>Per<bibref ref="Namespaces"/>, applications must use the value null as the namespaceURI parameter for methods if they wish to have no namespace.</p></descr><parameters><param name="arg" type="Node" attr="in"><descr><p>A node to store in this map. The node will later be accessible using the value of its<code>namespaceURI</code>and<code>localName</code>attributes.</p></descr></param></parameters><returns type="Node"><descr><p>If the new<code>Node</code>replaces an existing node the replaced<code>Node</code>is returned, otherwise<code>null</code>is returned.</p></descr></returns><raises><exception name="DOMException"><descr><p>WRONG_DOCUMENT_ERR: Raised if<code>arg</code>was created from a different document than the one that created this map.</p><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this map is readonly.</p><p>INUSE_ATTRIBUTE_ERR: Raised if<code>arg</code>is an<code>Attr</code>that is already an attribute of another<code>Element</code>object. The DOM user must explicitly clone<code>Attr</code>nodes to re-use them in other elements.</p><p>HIERARCHY_REQUEST_ERR: Raised if an attempt is made to add a node doesn't belong in this NamedNodeMap. Examples would include trying to insert something other than an Attr node into an Element's map of attributes, or a non-Entity node into the DocumentType's map of Entities.</p><p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature "XML" and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p></descr></exception></raises></method><method name="removeNamedItemNS" id="ID-removeNamedItemNS" since="DOM Level 2"><descr><p>Removes a node specified by local name and namespace URI. A removed attribute may be known to have a default value when this map contains the attributes attached to an element, as returned by the attributes attribute of the<code>Node</code>interface. If so, an attribute immediately appears containing the default value as well as the corresponding namespace URI, local name, and prefix when applicable.</p><p>Per<bibref ref="Namespaces"/>, applications must use the value null as the namespaceURI parameter for methods if they wish to have no namespace.</p></descr><parameters><param name="namespaceURI" type="DOMString" attr="in"><descr><p>The<termref def="dt-namespaceURI">namespace URI</termref>of the node to remove.</p></descr></param><param name="localName" type="DOMString" attr="in"><descr><p>The<termref def="dt-localname">local name</termref>of the node to remove.</p></descr></param></parameters><returns type="Node"><descr><p>The node removed from this map if a node with such a local name and namespace URI exists.</p></descr></returns><raises><exception name="DOMException"><descr><p>NOT_FOUND_ERR: Raised if there is no node with the specified<code>namespaceURI</code>and<code>localName</code>in this map.</p><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this map is readonly.</p><p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature "XML" and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p></descr></exception></raises></method></interface>
  <interface name="CharacterData" inherits="Node" id="ID-FF21A306"><descr><p>The<code>CharacterData</code>interface extends Node with a set of attributes and methods for accessing character data in the DOM. For clarity this set is defined here rather than on each object that uses these attributes and methods. No DOM objects correspond directly to<code>CharacterData</code>, though<code>Text</code>and others do inherit the interface from it. All<code>offsets</code>in this interface start from<code>0</code>.</p><p>As explained in the<code>DOMString</code>interface, text strings in the DOM are represented in UTF-16, i.e. as a sequence of 16-bit units. In the following, the term<termref def="dt-16-bit-unit">16-bit units</termref>is used whenever necessary to indicate that indexing on CharacterData is done in 16-bit units.</p></descr><attribute type="DOMString" name="data" id="ID-72AB8359" readonly="no"><descr><p>The character data of the node that implements this interface. The DOM implementation may not put arbitrary limits on the amount of data that may be stored in a<code>CharacterData</code>node. However, implementation limits may mean that the entirety of a node's data may not fit into a single<code>DOMString</code>. In such cases, the user may call<code>substringData</code>to retrieve the data in appropriately sized pieces.</p></descr><setraises><exception name="DOMException"><descr><p>NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.</p></descr></exception></setraises><getraises><exception name="DOMException"><descr><p>DOMSTRING_SIZE_ERR: Raised when it would return more characters than fit in a<code>DOMString</code>variable on the implementation platform.</p></descr></exception></getraises></attribute><attribute type="unsigned long" name="length" readonly="yes" id="ID-7D61178C"><descr><p>The number of<termref def="dt-16-bit-unit">16-bit units</termref>that are available through<code>data</code>and the<code>substringData</code>method below. This may have the value zero, i.e.,<code>CharacterData</code>nodes may be empty.</p></descr></attribute><method name="substringData" id="ID-6531BCCF"><descr><p>Extracts a range of data from the node.</p></descr><parameters><param name="offset" type="unsigned long" attr="in"><descr><p>Start offset of substring to extract.</p></descr></param><param name="count" type="unsigned long" attr="in"><descr><p>The number of 16-bit units to extract.</p></descr></param></parameters><returns type="DOMString"><descr><p>The specified substring. If the sum of<code>offset</code>and<code>count</code>exceeds the<code>length</code>, then all 16-bit units to the end of the data are returned.</p></descr></returns><raises><exception name="DOMException"><descr><p>INDEX_SIZE_ERR: Raised if the specified<code>offset</code>is negative or greater than the number of 16-bit units in<code>data</code>, or if the specified<code>count</code>is negative.</p><p>DOMSTRING_SIZE_ERR: Raised if the specified range of text does not fit into a<code>DOMString</code>.</p></descr></exception></raises></method><method name="appendData" id="ID-32791A2F"><descr><p>Append the string to the end of the character data of the node. Upon success,<code>data</code>provides access to the concatenation of<code>data</code>and the<code>DOMString</code>specified.</p></descr><parameters><param name="arg" type="DOMString" attr="in"><descr><p>The<code>DOMString</code>to append.</p></descr></param></parameters><returns type="void"><descr><p/></descr></returns><raises><exception name="DOMException"><descr><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p></descr></exception></raises></method><method name="insertData" id="ID-3EDB695F"><descr><p>Insert a string at the specified<termref def="dt-16-bit-unit">16-bit unit</termref>offset.</p></descr><parameters><param name="offset" type="unsigned long" attr="in"><descr><p>The character offset at which to insert.</p></descr></param><param name="arg" type="DOMString" attr="in"><descr><p>The<code>DOMString</code>to insert.</p></descr></param></parameters><returns type="void"><descr><p/></descr></returns><raises><exception name="DOMException"><descr><p>INDEX_SIZE_ERR: Raised if the specified<code>offset</code>is negative or greater than the number of 16-bit units in<code>data</code>.</p><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p></descr></exception></raises></method><method name="deleteData" id="ID-7C603781"><descr><p>Remove a range of<termref def="dt-16-bit-unit">16-bit units</termref>from the node. Upon success,<code>data</code>and<code>length</code>reflect the change.</p></descr><parameters><param name="offset" type="unsigned long" attr="in"><descr><p>The offset from which to start removing.</p></descr></param><param name="count" type="unsigned long" attr="in"><descr><p>The number of 16-bit units to delete. If the sum of<code>offset</code>and<code>count</code>exceeds<code>length</code>then all 16-bit units from<code>offset</code>to the end of the data are deleted.</p></descr></param></parameters><returns type="void"><descr><p/></descr></returns><raises><exception name="DOMException"><descr><p>INDEX_SIZE_ERR: Raised if the specified<code>offset</code>is negative or greater than the number of 16-bit units in<code>data</code>, or if the specified<code>count</code>is negative.</p><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p></descr></exception></raises></method><method name="replaceData" id="ID-E5CBA7FB"><descr><p>Replace the characters starting at the specified<termref def="dt-16-bit-unit">16-bit unit</termref>offset with the specified string.</p></descr><parameters><param name="offset" type="unsigned long" attr="in"><descr><p>The offset from which to start replacing.</p></descr></param><param name="count" type="unsigned long" attr="in"><descr><p>The number of 16-bit units to replace. If the sum of<code>offset</code>and<code>count</code>exceeds<code>length</code>, then all 16-bit units to the end of the data are replaced; (i.e., the effect is the same as a<code>remove</code>method call with the same range, followed by an<code>append</code>method invocation).</p></descr></param><param name="arg" type="DOMString" attr="in"><descr><p>The<code>DOMString</code>with which the range must be replaced.</p></descr></param></parameters><returns type="void"><descr><p/></descr></returns><raises><exception name="DOMException"><descr><p>INDEX_SIZE_ERR: Raised if the specified<code>offset</code>is negative or greater than the number of 16-bit units in<code>data</code>, or if the specified<code>count</code>is negative.</p><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p></descr></exception></raises></method></interface>
  <interface name="Attr" inherits="Node" id="ID-637646024"><descr><p>The<code>Attr</code>interface represents an attribute in an<code>Element</code>object. Typically the allowable values for the attribute are defined in a schema associated with the document.</p><p><code>Attr</code>objects inherit the<code>Node</code>interface, but since they are not actually child nodes of the element they describe, the DOM does not consider them part of the document tree. Thus, the<code>Node</code>attributes<code>parentNode</code>,<code>previousSibling</code>, and<code>nextSibling</code>have a<code>null</code>value for<code>Attr</code>objects. The DOM takes the view that attributes are properties of elements rather than having a separate identity from the elements they are associated with; this should make it more efficient to implement such features as default attributes associated with all elements of a given type. Furthermore,<code>Attr</code>nodes may not be immediate children of a<code>DocumentFragment</code>. However, they can be associated with<code>Element</code>nodes contained within a<code>DocumentFragment</code>. In short, users and implementors of the DOM need to be aware that<code>Attr</code>nodes have some things in common with other objects inheriting the<code>Node</code>interface, but they also are quite distinct.</p><p>The attribute's effective value is determined as follows: if this attribute has been explicitly assigned any value, that value is the attribute's effective value; otherwise, if there is a declaration for this attribute, and that declaration includes a default value, then that default value is the attribute's effective value; otherwise, the attribute does not exist on this element in the structure model until it has been explicitly added. Note that the<code>Node.nodeValue</code>attribute on the<code>Attr</code>instance can also be used to retrieve the string version of the attribute's value(s).</p><p>If the attribute was not explicitly given a value in the instance document but has a default value provided by the schema associated with the document, an attribute node will be created with<code>specified</code>set to<code>false</code>. Removing attribute nodes for which a default value is defined in the schema generates a new attribute node with the default value and<code>specified</code>set to<code>false</code>. If validation occurred while invoking<code>Document.normalizeDocument()</code>, attribute nodes with<code>specified</code>equals to<code>false</code>are recomputed according to the default attribute values provided by the schema. If no default value is associate with this attribute in the schema, the attribute node is discarded.</p><p>In XML, where the value of an attribute can contain entity references, the child nodes of the<code>Attr</code>node may be either<code>Text</code>or<code>EntityReference</code>nodes (when these are in use; see the description of<code>EntityReference</code>for discussion).</p><p>The DOM Core represents all attribute values as simple strings, even if the DTD or schema associated with the document declares them of some specific type such as<termref def="dt-tokenized">tokenized</termref>.</p><p>The way attribute value normalization is performed by the DOM implementation depends on how much the implementation knows about the schema in use. Typically, the<code>value</code>and<code>nodeValue</code>attributes of an<code>Attr</code>node initially returns the normalized value given by the parser. It is also the case after<code>Document.normalizeDocument()</code>is called (assuming the right options have been set). But this may not be the case after mutation, independently of whether the mutation is performed by setting the string value directly or by changing the<code>Attr</code>child nodes. In particular, this is true when<xspecref href="http://www.w3.org/TR/2004/REC-xml-20040204#dt-charref" type="simple" show="new" actuate="onRequest">character references</xspecref>are involved, given that they are not represented in the DOM and they impact attribute value normalization. On the other hand, if the implementation knows about the schema in use when the attribute value is changed, and it is of a different type than CDATA, it may normalize it again at that time. This is especially true of specialized DOM implementations, such as SVG DOM implementations, which store attribute values in an internal form different from a string.</p><p>The following table gives some examples of the relations between the attribute value in the original document (parsed attribute), the value as exposed in the DOM, and the serialization of the value:</p><table cellpadding="3" border="1" summary="Examples of differences between a parsed attribute,     its DOM representation, and its serialization"><tbody><tr><th rowspan="1" colspan="1">Examples</th><th rowspan="1" colspan="1">Parsed attribute value</th><th rowspan="1" colspan="1">Initial<code>Attr.value</code></th><th rowspan="1" colspan="1">Serialized attribute value</th></tr><tr><td rowspan="1" colspan="1">Character reference</td><td rowspan="1" colspan="1"><eg space="preserve">"x&amp;#178;=5"</eg></td><td rowspan="1" colspan="1"><eg space="preserve">"x²=5"</eg></td><td rowspan="1" colspan="1"><eg space="preserve">"x&amp;#178;=5"</eg></td></tr><tr><td rowspan="1" colspan="1">Built-in character entity</td><td rowspan="1" colspan="1"><eg space="preserve">"y&amp;lt;6"</eg></td><td rowspan="1" colspan="1"><eg space="preserve">"y&lt;6"</eg></td><td rowspan="1" colspan="1"><eg space="preserve">"y&amp;lt;6"</eg></td></tr><tr><td rowspan="1" colspan="1">Literal newline between</td><td rowspan="1" colspan="1"><eg space="preserve">"x=5&amp;#10;y=6"</eg></td><td rowspan="1" colspan="1"><eg space="preserve">"x=5 y=6"</eg></td><td rowspan="1" colspan="1"><eg space="preserve">"x=5&amp;#10;y=6"</eg></td></tr><tr><td rowspan="1" colspan="1">Normalized newline between</td><td rowspan="1" colspan="1"><eg space="preserve">"x=5 y=6"</eg></td><td rowspan="1" colspan="1"><eg space="preserve">"x=5 y=6"</eg></td><td rowspan="1" colspan="1"><eg space="preserve">"x=5 y=6"</eg></td></tr><tr><td rowspan="1" colspan="1">Entity<code>e</code>with literal newline</td><td rowspan="1" colspan="1"><eg space="preserve">&lt;!ENTITY e '...&amp;#10;...'&gt; [...]&gt; "x=5&amp;e;y=6"</eg></td><td rowspan="1" colspan="1"><emph>Dependent on Implementation and Load Options</emph></td><td rowspan="1" colspan="1"><emph>Dependent on Implementation and Load/Save Options</emph></td></tr></tbody></table></descr><attribute type="DOMString" readonly="yes" name="name" id="ID-1112119403"><descr><p>Returns the name of this attribute. If<code>Node.localName</code>is different from<code>null</code>, this attribute is a<termref def="dt-qualifiedname">qualified name</termref>.</p></descr></attribute><attribute type="boolean" readonly="yes" name="specified" id="ID-862529273"><descr><p><code>True</code>if this attribute was explicitly given a value in the instance document,<code>false</code>otherwise. If the application changed the value of this attribute node (even if it ends up having the same value as the default value) then it is set to<code>true</code>. The implementation may handle attributes with default values from other schemas similarly but applications should use<code>Document.normalizeDocument()</code>to guarantee this information is up-to-date.</p></descr></attribute><attribute type="DOMString" name="value" id="ID-221662474" readonly="no"><descr><p>On retrieval, the value of the attribute is returned as a string. Character and general entity references are replaced with their values. See also the method<code>getAttribute</code>on the<code>Element</code>interface.</p><p>On setting, this creates a<code>Text</code>node with the unparsed contents of the string, i.e. any characters that an XML processor would recognize as markup are instead treated as literal text. See also the method<code>Element.setAttribute()</code>.</p><p>Some specialized implementations, such as some<bibref ref="SVG1" role="informative"/>implementations, may do normalization automatically, even after mutation; in such case, the value on retrieval may differ from the value on setting.</p></descr><setraises><exception name="DOMException"><descr><p>NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.</p></descr></exception></setraises></attribute><attribute name="ownerElement" type="Element" readonly="yes" id="Attr-ownerElement" since="DOM Level 2"><descr><p>The<code>Element</code>node this attribute is attached to or<code>null</code>if this attribute is not in use.</p></descr></attribute><attribute name="schemaTypeInfo" type="TypeInfo" id="Attr-schemaTypeInfo" since="DOM Level 3" readonly="yes"><descr><p>The type information associated with this attribute. While the type information contained in this attribute is guarantee to be correct after loading the document or invoking<code>Document.normalizeDocument()</code>,<code>schemaTypeInfo</code>may not be reliable if the node was moved.</p></descr></attribute><attribute name="isId" id="Attr-isId" since="DOM Level 3" readonly="yes" type="boolean"><descr><p>Returns whether this attribute is known to be of type ID (i.e. to contain an identifier for its owner element) or not. When it is and its value is unique, the<code>ownerElement</code>of this attribute can be retrieved using the method<code>Document.getElementById</code>. The implementation could use several ways to determine if an attribute node is known to contain an identifier:</p><ulist><item><p>If validation occurred using an XML Schema<bibref ref="XMLSchema1"/>while loading the document or while invoking<code>Document.normalizeDocument()</code>, the post-schema-validation infoset contributions (PSVI contributions) values are used to determine if this attribute is a<term>schema-determined ID attribute</term>using the<loc href="http://www.w3.org/TR/2003/REC-xptr-framework-20030325/#term-sdi" type="simple" show="replace" actuate="onRequest">schema-determined ID</loc>definition in<bibref ref="XPointer"/>.</p></item><item><p>If validation occurred using a DTD while loading the document or while invoking<code>Document.normalizeDocument()</code>, the infoset<b>[type definition]</b>value is used to determine if this attribute is a<term>DTD-determined ID attribute</term>using the<loc href="http://www.w3.org/TR/2003/REC-xptr-framework-20030325/#term-ddi" type="simple" show="replace" actuate="onRequest">DTD-determined ID</loc>definition in<bibref ref="XPointer"/>.</p></item><item><p>from the use of the methods<code>Element.setIdAttribute()</code>,<code>Element.setIdAttributeNS()</code>, or<code>Element.setIdAttributeNode()</code>, i.e. it is an<term>user-determined ID attribute</term>;</p><note><p>XPointer framework (see section 3.2 in<bibref role="informative" ref="XPointer"/>) consider the DOM<term>user-determined ID attribute</term>as being part of the XPointer<term>externally-determined ID</term>definition.</p></note></item><item><p>using mechanisms that are outside the scope of this specification, it is then an<term>externally-determined ID attribute</term>. This includes using schema languages different from XML schema and DTD.</p></item></ulist><p>If validation occurred while invoking<code>Document.normalizeDocument()</code>, all<term>user-determined ID attributes</term>are reset and all attribute nodes ID information are then reevaluated in accordance to the schema used. As a consequence, if the<code>Attr.schemaTypeInfo</code>attribute contains an ID type,<code>isId</code>will always return true.</p></descr></attribute></interface>
  <interface name="Element" inherits="Node" id="ID-745549614"><descr><p>The<code>Element</code>interface represents an<termref def="dt-element">element</termref>in an HTML or XML document. Elements may have attributes associated with them; since the<code>Element</code>interface inherits from<code>Node</code>, the generic<code>Node</code>interface attribute<code>attributes</code>may be used to retrieve the set of all attributes for an element. There are methods on the<code>Element</code>interface to retrieve either an<code>Attr</code>object by name or an attribute value by name. In XML, where an attribute value may contain entity references, an<code>Attr</code>object should be retrieved to examine the possibly fairly complex sub-tree representing the attribute value. On the other hand, in HTML, where all attributes have simple string values, methods to directly access an attribute value can safely be used as a<termref def="dt-convenience">convenience</termref>.</p><note><p>In DOM Level 2, the method<code>normalize</code>is inherited from the<code>Node</code>interface where it was moved.</p></note></descr><attribute type="DOMString" name="tagName" readonly="yes" id="ID-104682815"><descr><p>The name of the element. If<code>Node.localName</code>is different from<code>null</code>, this attribute is a<termref def="dt-qualifiedname">qualified name</termref>. For example, in:<eg role="code" space="preserve">&lt;elementExample id="demo"&gt; ... &lt;/elementExample&gt; ,</eg><code>tagName</code>has the value<code>"elementExample"</code>. Note that this is case-preserving in XML, as are all of the operations of the DOM. The HTML DOM returns the<code>tagName</code>of an HTML element in the canonical uppercase form, regardless of the case in the source HTML document.</p></descr></attribute><method name="getAttribute" id="ID-666EE0F9"><descr><p>Retrieves an attribute value by name.</p></descr><parameters><param name="name" type="DOMString" attr="in"><descr><p>The name of the attribute to retrieve.</p></descr></param></parameters><returns type="DOMString"><descr><p>The<code>Attr</code>value as a string, or the empty string if that attribute does not have a specified or default value.</p></descr></returns><raises></raises></method><method name="setAttribute" id="ID-F68F082"><descr><p>Adds a new attribute. If an attribute with that name is already present in the element, its value is changed to be that of the value parameter. This value is a simple string; it is not parsed as it is being set. So any markup (such as syntax to be recognized as an entity reference) is treated as literal text, and needs to be appropriately escaped by the implementation when it is written out. In order to assign an attribute value that contains entity references, the user must create an<code>Attr</code>node plus any<code>Text</code>and<code>EntityReference</code>nodes, build the appropriate subtree, and use<code>setAttributeNode</code>to assign it as the value of an attribute.</p><p>To set an attribute with a qualified name and namespace URI, use the<code>setAttributeNS</code>method.</p></descr><parameters><param name="name" type="DOMString" attr="in"><descr><p>The name of the attribute to create or alter.</p></descr></param><param name="value" type="DOMString" attr="in"><descr><p>Value to set in string form.</p></descr></param></parameters><returns type="void"><descr><p/></descr></returns><raises><exception name="DOMException"><descr><p>INVALID_CHARACTER_ERR: Raised if the specified name is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p></descr></exception></raises></method><method name="removeAttribute" id="ID-6D6AC0F9"><descr><p>Removes an attribute by name. If a default value for the removed attribute is defined in the DTD, a new attribute immediately appears with the default value as well as the corresponding namespace URI, local name, and prefix when applicable. The implementation may handle default values from other schemas similarly but applications should use<code>Document.normalizeDocument()</code>to guarantee this information is up-to-date.</p><p>If no attribute with this name is found, this method has no effect.</p><p>To remove an attribute by local name and namespace URI, use the<code>removeAttributeNS</code>method.</p></descr><parameters><param name="name" type="DOMString" attr="in"><descr><p>The name of the attribute to remove.</p></descr></param></parameters><returns type="void"><descr><p/></descr></returns><raises><exception name="DOMException"><descr><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p></descr></exception></raises></method><method name="getAttributeNode" id="ID-217A91B8"><descr><p>Retrieves an attribute node by name.</p><p>To retrieve an attribute node by qualified name and namespace URI, use the<code>getAttributeNodeNS</code>method.</p></descr><parameters><param name="name" type="DOMString" attr="in"><descr><p>The name (<code>nodeName</code>) of the attribute to retrieve.</p></descr></param></parameters><returns type="Attr"><descr><p>The<code>Attr</code>node with the specified name (<code>nodeName</code>) or<code>null</code>if there is no such attribute.</p></descr></returns><raises></raises></method><method name="setAttributeNode" id="ID-887236154"><descr><p>Adds a new attribute node. If an attribute with that name (<code>nodeName</code>) is already present in the element, it is replaced by the new one. Replacing an attribute node by itself has no effect.</p><p>To add a new attribute node with a qualified name and namespace URI, use the<code>setAttributeNodeNS</code>method.</p></descr><parameters><param name="newAttr" type="Attr" attr="in"><descr><p>The<code>Attr</code>node to add to the attribute list.</p></descr></param></parameters><returns type="Attr"><descr><p>If the<code>newAttr</code>attribute replaces an existing attribute, the replaced<code>Attr</code>node is returned, otherwise<code>null</code>is returned.</p></descr></returns><raises><exception name="DOMException"><descr><p>WRONG_DOCUMENT_ERR: Raised if<code>newAttr</code>was created from a different document than the one that created the element.</p><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p><p>INUSE_ATTRIBUTE_ERR: Raised if<code>newAttr</code>is already an attribute of another<code>Element</code>object. The DOM user must explicitly clone<code>Attr</code>nodes to re-use them in other elements.</p></descr></exception></raises></method><method name="removeAttributeNode" id="ID-D589198"><descr><p>Removes the specified attribute node. If a default value for the removed<code>Attr</code>node is defined in the DTD, a new node immediately appears with the default value as well as the corresponding namespace URI, local name, and prefix when applicable. The implementation may handle default values from other schemas similarly but applications should use<code>Document.normalizeDocument()</code>to guarantee this information is up-to-date.</p></descr><parameters><param name="oldAttr" type="Attr" attr="in"><descr><p>The<code>Attr</code>node to remove from the attribute list.</p></descr></param></parameters><returns type="Attr"><descr><p>The<code>Attr</code>node that was removed.</p></descr></returns><raises><exception name="DOMException"><descr><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p><p>NOT_FOUND_ERR: Raised if<code>oldAttr</code>is not an attribute of the element.</p></descr></exception></raises></method><method name="getElementsByTagName" id="ID-1938918D"><descr><p>Returns a<code>NodeList</code>of all<termref def="dt-descendant">descendant</termref><code>Elements</code>with a given tag name, in<termref def="dt-document-order">document order</termref>.</p></descr><parameters><param name="tagname" type="DOMString" attr="in"><descr><p>The name of the tag to match on. The special value "*" matches all tags.</p></descr></param></parameters><returns type="NodeList"><descr><p>A list of matching<code>Element</code>nodes.</p></descr></returns><raises></raises></method><method name="getAttributeNS" id="ID-ElGetAttrNS" since="DOM Level 2"><descr><p>Retrieves an attribute value by local name and namespace URI.</p><p>Per<bibref ref="Namespaces"/>, applications must use the value<code>null</code>as the<code>namespaceURI</code>parameter for methods if they wish to have no namespace.</p></descr><parameters><param name="namespaceURI" type="DOMString" attr="in"><descr><p>The<termref def="dt-namespaceURI">namespace URI</termref>of the attribute to retrieve.</p></descr></param><param name="localName" type="DOMString" attr="in"><descr><p>The<termref def="dt-localname">local name</termref>of the attribute to retrieve.</p></descr></param></parameters><returns type="DOMString"><descr><p>The<code>Attr</code>value as a string, or the empty string if that attribute does not have a specified or default value.</p></descr></returns><raises><exception name="DOMException"><descr><p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature<code>"XML"</code>and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p></descr></exception></raises></method><method name="setAttributeNS" id="ID-ElSetAttrNS" since="DOM Level 2"><descr><p>Adds a new attribute. If an attribute with the same local name and namespace URI is already present on the element, its prefix is changed to be the prefix part of the<code>qualifiedName</code>, and its value is changed to be the<code>value</code>parameter. This value is a simple string; it is not parsed as it is being set. So any markup (such as syntax to be recognized as an entity reference) is treated as literal text, and needs to be appropriately escaped by the implementation when it is written out. In order to assign an attribute value that contains entity references, the user must create an<code>Attr</code>node plus any<code>Text</code>and<code>EntityReference</code>nodes, build the appropriate subtree, and use<code>setAttributeNodeNS</code>or<code>setAttributeNode</code>to assign it as the value of an attribute.</p><p>Per<bibref ref="Namespaces"/>, applications must use the value<code>null</code>as the<code>namespaceURI</code>parameter for methods if they wish to have no namespace.</p></descr><parameters><param name="namespaceURI" type="DOMString" attr="in"><descr><p>The<termref def="dt-namespaceURI">namespace URI</termref>of the attribute to create or alter.</p></descr></param><param name="qualifiedName" type="DOMString" attr="in"><descr><p>The<termref def="dt-qualifiedname">qualified name</termref>of the attribute to create or alter.</p></descr></param><param name="value" type="DOMString" attr="in"><descr><p>The value to set in string form.</p></descr></param></parameters><returns type="void"><descr><p/></descr></returns><raises><exception name="DOMException"><descr><p>INVALID_CHARACTER_ERR: Raised if the specified qualified name is not an XML name according to the XML version in use specified in the<code>Document.xmlVersion</code>attribute.</p><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p><p>NAMESPACE_ERR: Raised if the<code>qualifiedName</code>is malformed per the Namespaces in XML specification, if the<code>qualifiedName</code>has a prefix and the<code>namespaceURI</code>is<code>null</code>, if the<code>qualifiedName</code>has a prefix that is "xml" and the<code>namespaceURI</code>is different from "<loc href="http://www.w3.org/XML/1998/namespace" type="simple" show="replace" actuate="onRequest">http://www.w3.org/XML/1998/namespace</loc>", if the<code>qualifiedName</code>or its prefix is "xmlns" and the<code>namespaceURI</code>is different from "<loc href="http://www.w3.org/2000/xmlns/" type="simple" show="replace" actuate="onRequest">http://www.w3.org/2000/xmlns/</loc>", or if the<code>namespaceURI</code>is "<loc href="http://www.w3.org/2000/xmlns/" type="simple" show="replace" actuate="onRequest">http://www.w3.org/2000/xmlns/</loc>" and neither the<code>qualifiedName</code>nor its prefix is "xmlns".</p><p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature<code>"XML"</code>and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p></descr></exception></raises></method><method name="removeAttributeNS" id="ID-ElRemAtNS" since="DOM Level 2"><descr><p>Removes an attribute by local name and namespace URI. If a default value for the removed attribute is defined in the DTD, a new attribute immediately appears with the default value as well as the corresponding namespace URI, local name, and prefix when applicable. The implementation may handle default values from other schemas similarly but applications should use<code>Document.normalizeDocument()</code>to guarantee this information is up-to-date.</p><p>If no attribute with this local name and namespace URI is found, this method has no effect.</p><p>Per<bibref ref="Namespaces"/>, applications must use the value<code>null</code>as the<code>namespaceURI</code>parameter for methods if they wish to have no namespace.</p></descr><parameters><param name="namespaceURI" type="DOMString" attr="in"><descr><p>The<termref def="dt-namespaceURI">namespace URI</termref>of the attribute to remove.</p></descr></param><param name="localName" type="DOMString" attr="in"><descr><p>The<termref def="dt-localname">local name</termref>of the attribute to remove.</p></descr></param></parameters><returns type="void"><descr><p/></descr></returns><raises><exception name="DOMException"><descr><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p><p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature<code>"XML"</code>and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p></descr></exception></raises></method><method name="getAttributeNodeNS" id="ID-ElGetAtNodeNS" since="DOM Level 2"><descr><p>Retrieves an<code>Attr</code>node by local name and namespace URI.</p><p>Per<bibref ref="Namespaces"/>, applications must use the value<code>null</code>as the<code>namespaceURI</code>parameter for methods if they wish to have no namespace.</p></descr><parameters><param name="namespaceURI" type="DOMString" attr="in"><descr><p>The<termref def="dt-namespaceURI">namespace URI</termref>of the attribute to retrieve.</p></descr></param><param name="localName" type="DOMString" attr="in"><descr><p>The<termref def="dt-localname">local name</termref>of the attribute to retrieve.</p></descr></param></parameters><returns type="Attr"><descr><p>The<code>Attr</code>node with the specified attribute local name and namespace URI or<code>null</code>if there is no such attribute.</p></descr></returns><raises><exception name="DOMException"><descr><p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature<code>"XML"</code>and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p></descr></exception></raises></method><method name="setAttributeNodeNS" id="ID-ElSetAtNodeNS" since="DOM Level 2"><descr><p>Adds a new attribute. If an attribute with that local name and that namespace URI is already present in the element, it is replaced by the new one. Replacing an attribute node by itself has no effect.</p><p>Per<bibref ref="Namespaces"/>, applications must use the value<code>null</code>as the<code>namespaceURI</code>parameter for methods if they wish to have no namespace.</p></descr><parameters><param name="newAttr" type="Attr" attr="in"><descr><p>The<code>Attr</code>node to add to the attribute list.</p></descr></param></parameters><returns type="Attr"><descr><p>If the<code>newAttr</code>attribute replaces an existing attribute with the same<termref def="dt-localname">local name</termref>and<termref def="dt-namespaceURI">namespace URI</termref>, the replaced<code>Attr</code>node is returned, otherwise<code>null</code>is returned.</p></descr></returns><raises><exception name="DOMException"><descr><p>WRONG_DOCUMENT_ERR: Raised if<code>newAttr</code>was created from a different document than the one that created the element.</p><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p><p>INUSE_ATTRIBUTE_ERR: Raised if<code>newAttr</code>is already an attribute of another<code>Element</code>object. The DOM user must explicitly clone<code>Attr</code>nodes to re-use them in other elements.</p><p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature<code>"XML"</code>and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p></descr></exception></raises></method><method name="getElementsByTagNameNS" id="ID-A6C90942" since="DOM Level 2"><descr><p>Returns a<code>NodeList</code>of all the<termref def="dt-descendant">descendant</termref><code>Elements</code>with a given local name and namespace URI in<termref def="dt-document-order">document order</termref>.</p></descr><parameters><param name="namespaceURI" type="DOMString" attr="in"><descr><p>The<termref def="dt-namespaceURI">namespace URI</termref>of the elements to match on. The special value "*" matches all namespaces.</p></descr></param><param name="localName" type="DOMString" attr="in"><descr><p>The<termref def="dt-localname">local name</termref>of the elements to match on. The special value "*" matches all local names.</p></descr></param></parameters><returns type="NodeList"><descr><p>A new<code>NodeList</code>object containing all the matched<code>Elements</code>.</p></descr></returns><raises><exception name="DOMException"><descr><p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature<code>"XML"</code>and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p></descr></exception></raises></method><method name="hasAttribute" id="ID-ElHasAttr" since="DOM Level 2"><descr><p>Returns<code>true</code>when an attribute with a given name is specified on this element or has a default value,<code>false</code>otherwise.</p></descr><parameters><param name="name" type="DOMString" attr="in"><descr><p>The name of the attribute to look for.</p></descr></param></parameters><returns type="boolean"><descr><p><code>true</code>if an attribute with the given name is specified on this element or has a default value,<code>false</code>otherwise.</p></descr></returns><raises></raises></method><method name="hasAttributeNS" id="ID-ElHasAttrNS" since="DOM Level 2"><descr><p>Returns<code>true</code>when an attribute with a given local name and namespace URI is specified on this element or has a default value,<code>false</code>otherwise.</p><p>Per<bibref ref="Namespaces"/>, applications must use the value<code>null</code>as the<code>namespaceURI</code>parameter for methods if they wish to have no namespace.</p></descr><parameters><param name="namespaceURI" type="DOMString" attr="in"><descr><p>The<termref def="dt-namespaceURI">namespace URI</termref>of the attribute to look for.</p></descr></param><param name="localName" type="DOMString" attr="in"><descr><p>The<termref def="dt-localname">local name</termref>of the attribute to look for.</p></descr></param></parameters><returns type="boolean"><descr><p><code>true</code>if an attribute with the given local name and namespace URI is specified or has a default value on this element,<code>false</code>otherwise.</p></descr></returns><raises><exception name="DOMException"><descr><p>NOT_SUPPORTED_ERR: May be raised if the implementation does not support the feature<code>"XML"</code>and the language exposed through the Document does not support XML Namespaces (such as<bibref role="informative" ref="HTML40"/>).</p></descr></exception></raises></method><attribute name="schemaTypeInfo" type="TypeInfo" id="Element-schemaTypeInfo" since="DOM Level 3" readonly="yes"><descr><p>The type information associated with this element.</p></descr></attribute><method name="setIdAttribute" id="ID-ElSetIdAttr" since="DOM Level 3"><descr><p>If the parameter<code>isId</code>is<code>true</code>, this method declares the specified attribute to be a<term>user-determined ID attribute</term>. This affects the value of<code>Attr.isId</code>and the behavior of<code>Document.getElementById</code>, but does not change any schema that may be in use, in particular this does not affect the<code>Attr.schemaTypeInfo</code>of the specified<code>Attr</code>node. Use the value<code>false</code>for the parameter<code>isId</code>to undeclare an attribute for being a<term>user-determined ID attribute</term>.</p><p>To specify an attribute by local name and namespace URI, use the<code>setIdAttributeNS</code>method.</p></descr><parameters><param name="name" type="DOMString" attr="in"><descr><p>The name of the attribute.</p></descr></param><param name="isId" type="boolean" attr="in"><descr><p>Whether the attribute is a of type ID.</p></descr></param></parameters><returns type="void"><descr><p/></descr></returns><raises><exception name="DOMException"><descr><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p><p>NOT_FOUND_ERR: Raised if the specified node is not an attribute of this element.</p></descr></exception></raises></method><method name="setIdAttributeNS" id="ID-ElSetIdAttrNS" since="DOM Level 3"><descr><p>If the parameter<code>isId</code>is<code>true</code>, this method declares the specified attribute to be a<term>user-determined ID attribute</term>. This affects the value of<code>Attr.isId</code>and the behavior of<code>Document.getElementById</code>, but does not change any schema that may be in use, in particular this does not affect the<code>Attr.schemaTypeInfo</code>of the specified<code>Attr</code>node. Use the value<code>false</code>for the parameter<code>isId</code>to undeclare an attribute for being a<term>user-determined ID attribute</term>.</p></descr><parameters><param name="namespaceURI" type="DOMString" attr="in"><descr><p>The<termref def="dt-namespaceURI">namespace URI</termref>of the attribute.</p></descr></param><param name="localName" type="DOMString" attr="in"><descr><p>The<termref def="dt-localname">local name</termref>of the attribute.</p></descr></param><param name="isId" type="boolean" attr="in"><descr><p>Whether the attribute is a of type ID.</p></descr></param></parameters><returns type="void"><descr><p/></descr></returns><raises><exception name="DOMException"><descr><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p><p>NOT_FOUND_ERR: Raised if the specified node is not an attribute of this element.</p></descr></exception></raises></method><method name="setIdAttributeNode" id="ID-ElSetIdAttrNode" since="DOM Level 3"><descr><p>If the parameter<code>isId</code>is<code>true</code>, this method declares the specified attribute to be a<term>user-determined ID attribute</term>. This affects the value of<code>Attr.isId</code>and the behavior of<code>Document.getElementById</code>, but does not change any schema that may be in use, in particular this does not affect the<code>Attr.schemaTypeInfo</code>of the specified<code>Attr</code>node. Use the value<code>false</code>for the parameter<code>isId</code>to undeclare an attribute for being a<term>user-determined ID attribute</term>.</p></descr><parameters><param name="idAttr" type="Attr" attr="in"><descr><p>The attribute node.</p></descr></param><param name="isId" type="boolean" attr="in"><descr><p>Whether the attribute is a of type ID.</p></descr></param></parameters><returns type="void"><descr><p/></descr></returns><raises><exception name="DOMException"><descr><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p><p>NOT_FOUND_ERR: Raised if the specified node is not an attribute of this element.</p></descr></exception></raises></method></interface>
  <interface name="Text" inherits="CharacterData" id="ID-1312295772"><descr><p>The<code>Text</code>interface inherits from<code>CharacterData</code>and represents the textual content (termed<xspecref href="http://www.w3.org/TR/2004/REC-xml-20040204#syntax" type="simple" show="new" actuate="onRequest">character data</xspecref>in XML) of an<code>Element</code>or<code>Attr</code>. If there is no markup inside an element's content, the text is contained in a single object implementing the<code>Text</code>interface that is the only child of the element. If there is markup, it is parsed into the<termref def="dt-infoitem">information items</termref>(elements, comments, etc.) and<code>Text</code>nodes that form the list of children of the element.</p><p>When a document is first made available via the DOM, there is only one<code>Text</code>node for each block of text. Users may create adjacent<code>Text</code>nodes that represent the contents of a given element without any intervening markup, but should be aware that there is no way to represent the separations between these nodes in XML or HTML, so they will not (in general) persist between DOM editing sessions. The<code>Node.normalize()</code>method merges any such adjacent<code>Text</code>objects into a single node for each block of text.</p><p>No lexical check is done on the content of a<code>Text</code>node and, depending on its position in the document, some characters must be escaped during serialization using character references; e.g. the characters "&lt;&amp;" if the textual content is part of an element or of an attribute, the character sequence "]]&gt;" when part of an element, the quotation mark character " or the apostrophe character ' when part of an attribute.</p></descr><method name="splitText" id="ID-38853C1D"><descr><p>Breaks this node into two nodes at the specified<code>offset</code>, keeping both in the tree as<termref def="dt-sibling">siblings</termref>. After being split, this node will contain all the content up to the<code>offset</code>point. A new node of the same type, which contains all the content at and after the<code>offset</code>point, is returned. If the original node had a parent node, the new node is inserted as the next<termref def="dt-sibling">sibling</termref>of the original node. When the<code>offset</code>is equal to the length of this node, the new node has no data.</p></descr><parameters><param name="offset" type="unsigned long" attr="in"><descr><p>The<termref def="dt-16-bit-unit">16-bit unit</termref>offset at which to split, starting from<code>0</code>.</p></descr></param></parameters><returns type="Text"><descr><p>The new node, of the same type as this node.</p></descr></returns><raises><exception name="DOMException"><descr><p>INDEX_SIZE_ERR: Raised if the specified offset is negative or greater than the number of 16-bit units in<code>data</code>.</p><p>NO_MODIFICATION_ALLOWED_ERR: Raised if this node is readonly.</p></descr></exception></raises></method><attribute name="isElementContentWhitespace" id="Text3-isElementContentWhitespace" since="DOM Level 3" readonly="yes" type="boolean"><descr><p>Returns whether this text node contains<xspecref href="http://www.w3.org/TR/2004/REC-xml-infoset-20040204#infoitem.character" type="simple" show="new" actuate="onRequest">element content whitespace</xspecref>, often abusively called "ignorable whitespace". The text node is determined to contain whitespace in element content during the load of the document or if validation occurs while using<code>Document.normalizeDocument()</code>.</p></descr></attribute><attribute readonly="yes" type="DOMString" name="wholeText" id="Text3-wholeText" since="DOM Level 3"><descr><p>Returns all text of<code>Text</code>nodes<termref def="dt-logically-adjacent-text-nodes">logically-adjacent text nodes</termref>to this node, concatenated in document order.</p><p>For instance, in the example below<code>wholeText</code>on the<code>Text</code>node that contains "bar" returns "barfoo", while on the<code>Text</code>node that contains "foo" it returns "barfoo".</p><graphic source="./images/wholeTextExmpl.png" alt="barTextNode.wholeText value is &quot;barfoo&quot;" type="simple" show="embed" actuate="onLoad"/></descr></attribute><method name="replaceWholeText" id="Text3-replaceWholeText" since="DOM Level 3"><descr><p>Replaces the text of the current node and all<termref def="dt-logically-adjacent-text-nodes">logically-adjacent text nodes</termref>with the specified text. All<termref def="dt-logically-adjacent-text-nodes">logically-adjacent text nodes</termref>are removed including the current node unless it was the recipient of the replacement text.</p><p>This method returns the node which received the replacement text. The returned node is:</p><ulist><item><p><code>null</code>, when the replacement text is the empty string;</p></item><item><p>the current node, except when the current node is<termref def="dt-readonly-node">read-only</termref>;</p></item><item><p>a new<code>Text</code>node of the same type (<code>Text</code>or<code>CDATASection</code>) as the current node inserted at the location of the replacement.</p></item></ulist><p>For instance, in the above example calling<code>replaceWholeText</code>on the<code>Text</code>node that contains "bar" with "yo" in argument results in the following:</p><graphic source="./images/wholeTextExmpl2.png" alt="barTextNode.replaceWholeText(&quot;yo&quot;) modifies the textual content of barTextNode with &quot;yo&quot;" type="simple" show="embed" actuate="onLoad"/><p>Where the nodes to be removed are read-only descendants of an<code>EntityReference</code>, the<code>EntityReference</code>must be removed instead of the read-only nodes. If any<code>EntityReference</code>to be removed has descendants that are not<code>EntityReference</code>,<code>Text</code>, or<code>CDATASection</code>nodes, the<code>replaceWholeText</code>method must fail before performing any modification of the document, raising a<code>DOMException</code>with the code<code>NO_MODIFICATION_ALLOWED_ERR</code>.</p><p>For instance, in the example below calling<code>replaceWholeText</code>on the<code>Text</code>node that contains "bar" fails, because the<code>EntityReference</code>node "ent" contains an<code>Element</code>node which cannot be removed.</p><graphic source="./images/wholeTextExmpl3.png" alt="barTextNode.replaceWholeText(&quot;yo&quot;) raises a NO_MODIFICATION_ALLOWED_ERR DOMException" type="simple" show="embed" actuate="onLoad"/></descr><parameters><param name="content" type="DOMString" attr="in"><descr><p>The content of the replacing<code>Text</code>node.</p></descr></param></parameters><returns type="Text"><descr><p>The<code>Text</code>node created with the specified content.</p></descr></returns><raises><exception name="DOMException"><descr><p>NO_MODIFICATION_ALLOWED_ERR: Raised if one of the<code>Text</code>nodes being replaced is readonly.</p></descr></exception></raises></method></interface>
  <interface name="Comment" inherits="CharacterData" id="ID-1728279322"><descr><p>This interface inherits from<code>CharacterData</code>and represents the content of a comment, i.e., all the characters between the starting '<code>&lt;!--</code>' and ending '<code>--&gt;</code>'. Note that this is the definition of a comment in XML, and, in practice, HTML, although some HTML tools may implement the full SGML comment structure.</p><p>No lexical check is done on the content of a comment and it is therefore possible to have the character sequence<code>"--"</code>(double-hyphen) in the content, which is illegal in a comment per section 2.5 of<bibref ref="XML"/>. The presence of this character sequence must generate a fatal error during serialization.</p></descr></interface>
  <interface name="TypeInfo" id="TypeInfo" since="DOM Level 3"><descr><p>The<code>TypeInfo</code>interface represents a type referenced from<code>Element</code>or<code>Attr</code>nodes, specified in the<termref def="dt-schema">schemas</termref>associated with the document. The type is a pair of a<termref def="dt-namespaceURI">namespace URI</termref>and name properties, and depends on the document's schema.</p><p>If the document's schema is an XML DTD<bibref ref="XML"/>, the values are computed as follows:</p><ulist><item><p>If this type is referenced from an<code>Attr</code>node,<code>typeNamespace</code>is<code>"http://www.w3.org/TR/REC-xml"</code>and<code>typeName</code>represents the<b>[attribute type]</b>property in the<bibref ref="InfoSet"/>. If there is no declaration for the attribute,<code>typeNamespace</code>and<code>typeName</code>are<code>null</code>.</p></item><item><p>If this type is referenced from an<code>Element</code>node,<code>typeNamespace</code>and<code>typeName</code>are<code>null</code>.</p></item></ulist><p>If the document's schema is an XML Schema<bibref ref="XMLSchema1"/>, the values are computed as follows using the post-schema-validation infoset contributions (also called PSVI contributions):</p><ulist><item><p>If the<b>[validity]</b>property exists AND is<emph>"invalid"</emph>or<emph>"notKnown"</emph>: the {target namespace} and {name} properties of the declared type if available, otherwise<code>null</code>.</p><note><p>At the time of writing, the XML Schema specification does not require exposing the declared type. Thus, DOM implementations might choose not to provide type information if validity is not valid.</p></note></item><item><p>If the<b>[validity]</b>property exists and is<emph>"valid"</emph>:</p><olist><item><p>If<b>[member type definition]</b>exists:</p><olist><item><p>If {name} is not absent, then expose {name} and {target namespace} properties of the<b>[member type definition]</b>property;</p></item><item><p>Otherwise, expose the namespace and local name of the corresponding<termref def="dt-anonymous">anonymous type name</termref>.</p></item></olist></item><item><p>If the<b>[type definition]</b>property exists:<olist><item><p>If {name} is not absent, then expose {name} and {target namespace} properties of the<b>[type definition]</b>property;</p></item><item><p>Otherwise, expose the namespace and local name of the corresponding<termref def="dt-anonymous">anonymous type name</termref>.</p></item></olist></p></item><item><p>If the<b>[member type definition anonymous]</b>exists:<olist><item><p>If it is false, then expose<b>[member type definition name]</b>and<b>[member type definition namespace]</b>properties;</p></item><item><p>Otherwise, expose the namespace and local name of the corresponding<termref def="dt-anonymous">anonymous type name</termref>.</p></item></olist></p></item><item><p>If the<b>[type definition anonymous]</b>exists:<olist><item><p>If it is false, then expose<b>[type definition name]</b>and<b>[type definition namespace]</b>properties;</p></item><item><p>Otherwise, expose the namespace and local name of the corresponding<termref def="dt-anonymous">anonymous type name</termref>.</p></item></olist></p></item></olist></item></ulist><note><p>Other schema languages are outside the scope of the W3C and therefore should define how to represent their type systems using<code>TypeInfo</code>.</p></note></descr><attribute name="typeName" type="DOMString" id="TypeInfo-typeName" readonly="yes"><descr><p>The name of a type declared for the associated element or attribute, or<code>null</code>if unknown.</p></descr></attribute><attribute name="typeNamespace" type="DOMString" id="TypeInfo-typeNamespace" readonly="yes"><descr><p>The namespace of the type declared for the associated element or attribute or<code>null</code>if the element does not have declaration or if no namespace information is available.</p></descr></attribute><group name="DerivationMethods" id="TypeInfo-DerivationMethods"><descr><p>These are the available values for the<code>derivationMethod</code>parameter used by the method<code>TypeInfo.isDerivedFrom()</code>. It is a set of possible types of derivation, and the values represent bit positions. If a bit in the<code>derivationMethod</code>parameter is set to<code>1</code>, the corresponding type of derivation will be taken into account when evaluating the derivation between the reference type definition and the other type definition. When using the<code>isDerivedFrom</code>method, combining all of them in the<code>derivationMethod</code>parameter is equivalent to invoking the method for each of them separately and combining the results with the OR boolean function. This specification only defines the type of derivation for XML Schema.</p><p>In addition to the types of derivation listed below, please note that:</p><ulist><item><p>any type derives from<code>xsd:anyType</code>.</p></item><item><p>any simple type derives from<code>xsd:anySimpleType</code>by<term>restriction</term>.</p></item><item><p>any complex type does not derive from<code>xsd:anySimpleType</code>by<term>restriction</term>.</p></item></ulist></descr><constant id="TypeInfo-DERIVATION_RESTRICTION" name="DERIVATION_RESTRICTION" type="unsigned long" value="0x00000001"><descr><p>If the document's schema is an XML Schema<bibref ref="XMLSchema1"/>, this constant represents the derivation by<xspecref href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeRestriction" type="simple" show="new" actuate="onRequest">restriction</xspecref>if complex types are involved, or a<xspecref href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-restriction" type="simple" show="new" actuate="onRequest">restriction</xspecref>if simple types are involved.</p><p><termdef id="id-restriction" term="restriction">The reference type definition is derived by<term>restriction</term>from the other type definition if the other type definition is the same as the reference type definition, or if the other type definition can be reached recursively following the {base type definition} property from the reference type definition, and all the<emph>derivation methods</emph>involved are<term>restriction</term>.</termdef></p></descr></constant><constant id="TypeInfo-DERIVATION_EXTENSION" name="DERIVATION_EXTENSION" type="unsigned long" value="0x00000002"><descr><p>If the document's schema is an XML Schema<bibref ref="XMLSchema1"/>, this constant represents the derivation by<xspecref href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-typeExtension" type="simple" show="new" actuate="onRequest">extension</xspecref>.</p><p><termdef id="id-extension" term="extension">The reference type definition is derived by<term>extension</term>from the other type definition if the other type definition can be reached recursively following the {base type definition} property from the reference type definition, and at least one of the<emph>derivation methods</emph>involved is an<term>extension</term>.</termdef></p></descr></constant><constant id="TypeInfo-DERIVATION_UNION" name="DERIVATION_UNION" type="unsigned long" value="0x00000004"><descr><p>If the document's schema is an XML Schema<bibref ref="XMLSchema1"/>, this constant represents the<xspecref href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-union" type="simple" show="new" actuate="onRequest">union</xspecref>if simple types are involved.</p><p><termdef id="id-union" term="union">The reference type definition is derived by<term>union</term>from the other type definition if there exists two type definitions T1 and T2 such as the reference type definition is derived from T1 by<code>DERIVATION_RESTRICTION</code>or<code>DERIVATION_EXTENSION</code>, T2 is derived from the other type definition by<code>DERIVATION_RESTRICTION</code>, T1 has {variety}<emph>union</emph>, and one of the {member type definitions} is T2. Note that T1 could be the same as the reference type definition, and T2 could be the same as the other type definition.</termdef></p></descr></constant><constant id="TypeInfo-DERIVATION_LIST" name="DERIVATION_LIST" type="unsigned long" value="0x00000008"><descr><p>If the document's schema is an XML Schema<bibref ref="XMLSchema1"/>, this constant represents the<xspecref href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#element-list" type="simple" show="new" actuate="onRequest">list</xspecref>.</p><p><termdef id="id-list" term="list">The reference type definition is derived by<term>list</term>from the other type definition if there exists two type definitions T1 and T2 such as the reference type definition is derived from T1 by<code>DERIVATION_RESTRICTION</code>or<code>DERIVATION_EXTENSION</code>, T2 is derived from the other type definition by<code>DERIVATION_RESTRICTION</code>, T1 has {variety}<emph>list</emph>, and T2 is the {item type definition}. Note that T1 could be the same as the reference type definition, and T2 could be the same as the other type definition.</termdef></p></descr></constant></group><method name="isDerivedFrom" id="TypeInfo-isDerivedFrom"><descr><p>This method returns if there is a derivation between the reference type definition, i.e. the<code>TypeInfo</code>on which the method is being called, and the other type definition, i.e. the one passed as parameters.</p></descr><parameters><param name="typeNamespaceArg" type="DOMString" attr="in"><descr><p>the namespace of the other type definition.</p></descr></param><param name="typeNameArg" type="DOMString" attr="in"><descr><p>the name of the other type definition.</p></descr></param><param name="derivationMethod" type="unsigned long" attr="in"><descr><p>the type of derivation and conditions applied between two types, as described in the list of constants provided in this interface.</p></descr></param></parameters><returns type="boolean"><descr><p>If the document's schema is a DTD or no schema is associated with the document, this method will always return<code>false</code>.</p><p>If the document's schema is an XML Schema, the method will<code>true</code>if the reference type definition is derived from the other type definition according to the derivation parameter. If the value of the parameter is<code>0</code>(no bit is set to<code>1</code>for the<code>derivationMethod</code>parameter), the method will return<code>true</code>if the other type definition can be reached by recursing any combination of {base type definition}, {item type definition}, or {member type definitions} from the reference type definition.</p></descr></returns><raises></raises></method></interface>
  <interface name="UserDataHandler" id="UserDataHandler" since="DOM Level 3" role="ecmascript-function"><descr><p>When associating an object to a key on a node using<code>Node.setUserData()</code>the application can provide a handler that gets called when the node the object is associated to is being cloned, imported, or renamed. This can be used by the application to implement various behaviors regarding the data it associates to the DOM nodes. This interface defines that handler.</p></descr><group id="ID-UserDataOperation" name="OperationType"><descr><p>An integer indicating the type of operation being performed on a node.</p></descr><constant id="UserDataHandler-CLONED" name="NODE_CLONED" type="unsigned short" value="1"><descr><p>The node is cloned, using<code>Node.cloneNode()</code>.</p></descr></constant><constant id="UserDataHandler-IMPORTED" name="NODE_IMPORTED" type="unsigned short" value="2"><descr><p>The node is imported, using<code>Document.importNode()</code>.</p></descr></constant><constant id="UserDataHandler-DELETED" name="NODE_DELETED" type="unsigned short" value="3"><descr><p>The node is deleted.</p><note><p>This may not be supported or may not be reliable in certain environments, such as Java, where the implementation has no real control over when objects are actually deleted.</p></note></descr></constant><constant id="UserDataHandler-RENAMED" name="NODE_RENAMED" type="unsigned short" value="4"><descr><p>The node is renamed, using<code>Document.renameNode()</code>.</p></descr></constant><constant id="UserDataHandler-ADOPTED" name="NODE_ADOPTED" type="unsigned short" value="5"><descr><p>The node is adopted, using<code>Document.adoptNode()</code>.</p></descr></constant></group><method name="handle" id="ID-handleUserDataEvent"><descr><p>This method is called whenever the node for which this handler is registered is imported or cloned.</p><p>DOM applications must not raise exceptions in a<code>UserDataHandler</code>. The effect of throwing exceptions from the handler is DOM implementation dependent.</p></descr><parameters><param name="operation" type="unsigned short" attr="in"><descr><p>Specifies the type of operation that is being performed on the node.</p></descr></param><param name="key" type="DOMString" attr="in"><descr><p>Specifies the key for which this handler is being called.</p></descr></param><param name="data" type="DOMUserData" attr="in"><descr><p>Specifies the data for which this handler is being called.</p></descr></param><param name="src" type="Node" attr="in"><descr><p>Specifies the node being cloned, adopted, imported, or renamed. This is<code>null</code>when the node is being deleted.</p></descr></param><param name="dst" type="Node" attr="in"><descr><p>Specifies the node newly created if any, or<code>null</code>.</p></descr></param></parameters><returns type="void"><descr><p/></descr></returns><raises></raises></method></interface>
  <interface name="DOMError" id="ERROR-Interfaces-DOMError" since="DOM Level 3"><descr><p><code>DOMError</code>is an interface that describes an error.</p></descr><group id="DOMError-errorSeverityCodes" name="ErrorSeverity"><descr><p>An integer indicating the severity of the error.</p></descr><constant name="SEVERITY_WARNING" id="ERROR-DOMError-severity-warning" type="unsigned short" value="1"><descr><p>The severity of the error described by the<code>DOMError</code>is warning. A<code>SEVERITY_WARNING</code>will not cause the processing to stop, unless<code>DOMErrorHandler.handleError()</code>returns<code>false</code>.</p></descr></constant><constant name="SEVERITY_ERROR" id="ERROR-DOMError-severity-error" type="unsigned short" value="2"><descr><p>The severity of the error described by the<code>DOMError</code>is error. A<code>SEVERITY_ERROR</code>may not cause the processing to stop if the error can be recovered, unless<code>DOMErrorHandler.handleError()</code>returns<code>false</code>.</p></descr></constant><constant name="SEVERITY_FATAL_ERROR" id="ERROR-DOMError-severity-fatal-error" type="unsigned short" value="3"><descr><p>The severity of the error described by the<code>DOMError</code>is fatal error. A<code>SEVERITY_FATAL_ERROR</code>will cause the normal processing to stop. The return value of<code>DOMErrorHandler.handleError()</code>is ignored unless the implementation chooses to continue, in which case the behavior becomes undefined.</p></descr></constant></group><attribute type="unsigned short" readonly="yes" name="severity" id="ERROR-DOMError-severity"><descr><p>The severity of the error, either<code>SEVERITY_WARNING</code>,<code>SEVERITY_ERROR</code>, or<code>SEVERITY_FATAL_ERROR</code>.</p></descr></attribute><attribute type="DOMString" readonly="yes" name="message" id="ERROR-DOMError-message"><descr><p>An implementation specific string describing the error that occurred.</p></descr></attribute><attribute name="type" type="DOMString" readonly="yes" id="ERROR-DOMError-type"><descr><p>A<code>DOMString</code>indicating which related data is expected in<code>relatedData</code>. Users should refer to the specification of the error in order to find its<code>DOMString</code>type and<code>relatedData</code>definitions if any.</p><note><p>As an example,<code>Document.normalizeDocument()</code>does generate warnings when the "<termref def="parameter-split-cdata-sections">split-cdata-sections</termref>" parameter is in use. Therefore, the method generates a<code>SEVERITY_WARNING</code>with<code>type</code><code>"cdata-sections-splitted"</code>and the first<code>CDATASection</code>node in document order resulting from the split is returned by the<code>relatedData</code>attribute.</p></note></descr></attribute><attribute type="DOMObject" readonly="yes" name="relatedException" id="ERROR-DOMError-relatedException"><descr><p>The related platform dependent exception if any.</p></descr></attribute><attribute type="DOMObject" readonly="yes" name="relatedData" id="ERROR-DOMError-relatedData"><descr><p>The related<code>DOMError.type</code>dependent data if any.</p></descr></attribute><attribute type="DOMLocator" readonly="yes" name="location" id="ERROR-DOMError-location"><descr><p>The location of the error.</p></descr></attribute></interface>
  <interface name="DOMErrorHandler" id="ERROR-Interfaces-DOMErrorHandler" since="DOM Level 3" role="ecmascript-function"><descr><p><code>DOMErrorHandler</code>is a callback interface that the DOM implementation can call when reporting errors that happens while processing XML data, or when doing some other processing (e.g. validating a document). A<code>DOMErrorHandler</code>object can be attached to a<code>Document</code>using the "<termref def="parameter-error-handler">error-handler</termref>" on the<code>DOMConfiguration</code>interface. If more than one error needs to be reported during an operation, the sequence and numbers of the errors passed to the error handler are implementation dependent.</p><p>The application that is using the DOM implementation is expected to implement this interface.</p></descr><method name="handleError" id="ID-ERRORS-DOMErrorHandler-handleError"><descr><p>This method is called on the error handler when an error occurs.</p><p>If an exception is thrown from this method, it is considered to be equivalent of returning<code>true</code>.</p></descr><parameters><param name="error" type="DOMError" attr="in"><descr><p>The error object that describes the error. This object may be reused by the DOM implementation across multiple calls to the<code>handleError</code>method.</p></descr></param></parameters><returns type="boolean"><descr><p>If the<code>handleError</code>method returns<code>false</code>, the DOM implementation should stop the current processing when possible. If the method returns<code>true</code>, the processing may continue depending on<code>DOMError.severity</code>.</p></descr></returns><raises></raises></method></interface>
  <interface name="DOMLocator" id="Interfaces-DOMLocator" since="DOM Level 3"><descr><p><code>DOMLocator</code>is an interface that describes a location (e.g. where an error occurred).</p></descr><attribute type="long" readonly="yes" name="lineNumber" id="DOMLocator-line-number"><descr><p>The line number this locator is pointing to, or<code>-1</code>if there is no column number available.</p></descr></attribute><attribute type="long" readonly="yes" name="columnNumber" id="DOMLocator-column-number"><descr><p>The column number this locator is pointing to, or<code>-1</code>if there is no column number available.</p></descr></attribute><attribute type="long" readonly="yes" name="byteOffset" id="DOMLocator-byteOffset"><descr><p>The byte offset into the input source this locator is pointing to or<code>-1</code>if there is no byte offset available.</p></descr></attribute><attribute type="long" readonly="yes" name="utf16Offset" id="DOMLocator-utf16Offset"><descr><p>The UTF-16, as defined in<bibref ref="Unicode"/>and Amendment 1 of<bibref ref="ISO10646"/>, offset into the input source this locator is pointing to or<code>-1</code>if there is no UTF-16 offset available.</p></descr></attribute><attribute type="Node" readonly="yes" name="relatedNode" id="DOMLocator-node"><descr><p>The node this locator is pointing to, or<code>null</code>if no node is available.</p></descr></attribute><attribute type="DOMString" readonly="yes" name="uri" id="DOMLocator-uri"><descr><p>The URI this locator is pointing to, or<code>null</code>if no URI is available.</p></descr></attribute></interface>
  <interface name="DOMConfiguration" id="DOMConfiguration" since="DOM Level 3"><descr><p>The<code>DOMConfiguration</code>interface represents the configuration of a document and maintains a table of recognized parameters. Using the configuration, it is possible to change<code>Document.normalizeDocument()</code>behavior, such as replacing the<code>CDATASection</code>nodes with<code>Text</code>nodes or specifying the type of the<termref def="dt-schema">schema</termref>that must be used when the validation of the<code>Document</code>is requested.<code>DOMConfiguration</code>objects are also used in<bibref role="informative" ref="DOMLS"/>in the<code>DOMParser</code>and<code>DOMSerializer</code>interfaces.</p><p>The parameter names used by the<code>DOMConfiguration</code>object are defined throughout the DOM Level 3 specifications. Names are case-insensitive. To avoid possible conflicts, as a convention, names referring to parameters defined outside the DOM specification should be made unique. Because parameters are exposed as properties in the<specref ref="ecma-binding"/>, names are recommended to follow the section<quote>5.16 Identifiers</quote>of<bibref role="informative" ref="Unicode"/>with the addition of the character '-' (HYPHEN-MINUS) but it is not enforced by the DOM implementation. DOM Level 3 Core Implementations are required to recognize all parameters defined in this specification. Some parameter values may also be required to be supported by the implementation. Refer to the definition of the parameter to know if a value must be supported or not.</p><note><p>Parameters are similar to features and properties used in SAX2<bibref role="informative" ref="SAX"/>.</p></note><p>The following list of parameters defined in the DOM:</p><glist><gitem><label id="parameter-canonical-form"><code>"canonical-form"</code></label><def><glist><gitem><label><code>true</code></label><def><p>[<emph>optional</emph>]</p><p>Canonicalize the document according to the rules specified in<bibref role="informative" ref="c14n"/>, such as removing the<code>DocumentType</code>node (if any) from the tree, or removing superfluous namespace declarations from each element. Note that this is limited to what can be represented in the DOM; in particular, there is no way to specify the order of the attributes in the DOM. In addition,</p><p>Setting this parameter to<code>true</code>will also set the state of the parameters listed below. Later changes to the state of one of those parameters will revert "<termref def="parameter-canonical-form">canonical-form</termref>" back to<code>false</code>.</p><p>Parameters set to<code>false</code>: "<termref def="parameter-entities">entities</termref>", "<termref def="parameter-normalize-characters">normalize-characters</termref>", "<termref def="parameter-cdata-sections">cdata-sections</termref>".</p><p>Parameters set to<code>true</code>: "<termref def="parameter-namespaces">namespaces</termref>", "<termref def="parameter-namespace-declarations">namespace-declarations</termref>", "<termref def="parameter-well-formed">well-formed</termref>", "<termref def="parameter-element-content-whitespace">element-content-whitespace</termref>".</p><p>Other parameters are not changed unless explicitly specified in the description of the parameters.</p></def></gitem><gitem><label><code>false</code></label><def><p>[<emph>required</emph>] (<emph>default</emph>)</p><p>Do not canonicalize the document.</p></def></gitem></glist></def></gitem><gitem><label id="parameter-cdata-sections"><code>"cdata-sections"</code></label><def><glist><gitem><label><code>true</code></label><def><p>[<emph>required</emph>] (<emph>default</emph>)</p><p>Keep<code>CDATASection</code>nodes in the document.</p></def></gitem><gitem><label><code>false</code></label><def><p>[<emph>required</emph>]</p><p>Transform<code>CDATASection</code>nodes in the document into<code>Text</code>nodes. The new<code>Text</code>node is then combined with any adjacent<code>Text</code>node.</p></def></gitem></glist></def></gitem><gitem><label id="parameter-check-character-normalization"><code>"check-character-normalization"</code></label><def><glist><gitem><label><code>true</code></label><def><p>[<emph>optional</emph>]</p><p>Check if the characters in the document are<loc href="http://www.w3.org/TR/2004/REC-xml11-20040204/#dt-fullnorm" type="simple" show="replace" actuate="onRequest">fully normalized</loc>, as defined in appendix B of<bibref ref="XML11"/>. When a sequence of characters is encountered that fails normalization checking, an error with the<code>DOMError.type</code>equals to "check-character-normalization-failure" is issued.</p></def></gitem><gitem><label><code>false</code></label><def><p>[<emph>required</emph>] (<emph>default</emph>)</p><p>Do not check if characters are normalized.</p></def></gitem></glist></def></gitem><gitem><label id="parameter-comments"><code>"comments"</code></label><def><glist><gitem><label><code>true</code></label><def><p>[<emph>required</emph>] (<emph>default</emph>)</p><p>Keep<code>Comment</code>nodes in the document.</p></def></gitem><gitem><label><code>false</code></label><def><p>[<emph>required</emph>]</p><p>Discard<code>Comment</code>nodes in the document.</p></def></gitem></glist></def></gitem><gitem><label id="parameter-datatype-normalization"><code>"datatype-normalization"</code></label><def><glist><gitem><label><code>true</code></label><def><p>[<emph>optional</emph>]</p><p>Expose schema normalized values in the tree, such as<loc href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/#key-nv" type="simple" show="replace" actuate="onRequest">XML Schema normalized values</loc>in the case of XML Schema. Since this parameter requires to have<termref def="dt-schema">schema</termref>information, the "<termref def="parameter-validate">validate</termref>" parameter will also be set to<code>true</code>. Having this parameter activated when "validate" is<code>false</code>has no effect and no schema-normalization will happen.</p><note><p>Since the document contains the result of the XML 1.0 processing, this parameter does not apply to attribute value normalization as defined in section 3.3.3 of<bibref ref="XML"/>and is only meant for<termref def="dt-schema">schema</termref>languages other than Document Type Definition (DTD).</p></note></def></gitem><gitem><label><code>false</code></label><def><p>[<emph>required</emph>] (<emph>default</emph>)</p><p>Do not perform schema normalization on the tree.</p></def></gitem></glist></def></gitem><gitem><label id="parameter-element-content-whitespace"><code>"element-content-whitespace"</code></label><def><glist><gitem><label><code>true</code></label><def><p>[<emph>required</emph>] (<emph>default</emph>)</p><p>Keep all whitespaces in the document.</p></def></gitem><gitem><label><code>false</code></label><def><p>[<emph>optional</emph>]</p><p>Discard all<code>Text</code>nodes that contain whitespaces in element content, as described in<xspecref href="http://www.w3.org/TR/2004/REC-xml-infoset-20040204#infoitem.character" type="simple" show="new" actuate="onRequest">[element content whitespace]</xspecref>. The implementation is expected to use the attribute<code>Text.isElementContentWhitespace</code>to determine if a<code>Text</code>node should be discarded or not.</p></def></gitem></glist></def></gitem><gitem><label id="parameter-entities"><code>"entities"</code></label><def><glist><gitem><label><code>true</code></label><def><p>[<emph>required</emph>] (<emph>default</emph>)</p><p>Keep<code>EntityReference</code>nodes in the document.</p></def></gitem><gitem><label><code>false</code></label><def><p>[<emph>required</emph>]</p><p>Remove all<code>EntityReference</code>nodes from the document, putting the entity expansions directly in their place.<code>Text</code>nodes are normalized, as defined in<code>Node.normalize</code>. Only<loc href="http://www.w3.org/TR/2004/REC-xml-infoset-20040204/#infoitem.rse" type="simple" show="replace" actuate="onRequest">unexpanded entity references</loc>are kept in the document.</p></def></gitem></glist><note><p>This parameter does not affect<code>Entity</code>nodes.</p></note></def></gitem><gitem><label id="parameter-error-handler"><code>"error-handler"</code></label><def><p>[<emph>required</emph>]</p><p>Contains a<code>DOMErrorHandler</code>object. If an error is encountered in the document, the implementation will call back the<code>DOMErrorHandler</code>registered using this parameter. The implementation may provide a default<code>DOMErrorHandler</code>object.</p><p>When called,<code>DOMError.relatedData</code>will contain the closest node to where the error occurred. If the implementation is unable to determine the node where the error occurs,<code>DOMError.relatedData</code>will contain the<code>Document</code>node. Mutations to the document from within an error handler will result in implementation dependent behavior.</p></def></gitem><gitem><label id="parameter-infoset"><code>"infoset"</code></label><def><glist><gitem><label><code>true</code></label><def><p>[<emph>required</emph>]</p><p>Keep in the document the information defined in the XML Information Set<bibref ref="InfoSet"/>.</p><p>This forces the following parameters to<code>false</code>: "<termref def="parameter-validate-if-schema">validate-if-schema</termref>", "<termref def="parameter-entities">entities</termref>", "<termref def="parameter-datatype-normalization">datatype-normalization</termref>", "<termref def="parameter-cdata-sections">cdata-sections</termref>".</p><p>This forces the following parameters to<code>true</code>: "<termref def="parameter-namespace-declarations">namespace-declarations</termref>", "<termref def="parameter-well-formed">well-formed</termref>", "<termref def="parameter-element-content-whitespace">element-content-whitespace</termref>", "<termref def="parameter-comments">comments</termref>", "<termref def="parameter-namespaces">namespaces</termref>".</p><p>Other parameters are not changed unless explicitly specified in the description of the parameters.</p><p>Note that querying this parameter with<code>getParameter</code>returns<code>true</code>only if the individual parameters specified above are appropriately set.</p></def></gitem><gitem><label><code>false</code></label><def><p>Setting<code>infoset</code>to<code>false</code>has no effect.</p></def></gitem></glist></def></gitem><gitem><label id="parameter-namespaces"><code>"namespaces"</code></label><def><glist><gitem><label><code>true</code></label><def><p>[<emph>required</emph>] (<emph>default</emph>)</p><p>Perform the namespace processing as defined in<specref ref="normalizeDocumentAlgo"/>.</p></def></gitem><gitem><label><code>false</code></label><def><p>[<emph>optional</emph>]</p><p>Do not perform the namespace processing.</p></def></gitem></glist></def></gitem><gitem><label id="parameter-namespace-declarations"><code>"namespace-declarations"</code></label><def><p>This parameter has no effect if the parameter "<termref def="parameter-namespaces">namespaces</termref>" is set to<code>false</code>.</p><glist><gitem><label><code>true</code></label><def><p>[<emph>required</emph>] (<emph>default</emph>)</p><p>Include namespace declaration attributes, specified or defaulted from the<termref def="dt-schema">schema</termref>, in the document. See also the sections "Declaring Namespaces" in<bibref ref="Namespaces"/>and<bibref ref="Namespaces11"/>.</p></def></gitem><gitem><label><code>false</code></label><def><p>[<emph>required</emph>]</p><p>Discard all namespace declaration attributes. The namespace prefixes (<code>Node.prefix</code>) are retained even if this parameter is set to<code>false</code>.</p></def></gitem></glist></def></gitem><gitem><label id="parameter-normalize-characters"><code>"normalize-characters"</code></label><def><glist><gitem><label><code>true</code></label><def><p>[<emph>optional</emph>]</p><p><loc href="http://www.w3.org/TR/2004/REC-xml11-20040204/#dt-fullnorm" type="simple" show="replace" actuate="onRequest">Fully normalized</loc>the characters in the document as defined in appendix B of<bibref ref="XML11"/>.</p></def></gitem><gitem><label><code>false</code></label><def><p>[<emph>required</emph>] (<emph>default</emph>)</p><p>Do not perform character normalization.</p></def></gitem></glist></def></gitem><gitem><label id="parameter-schema-location"><code>"schema-location"</code></label><def><p>[<emph>optional</emph>]</p><p>Represent a<code>DOMString</code>object containing a list of URIs, separated by whitespaces (characters matching the<xspecref href="http://www.w3.org/TR/2004/REC-xml-20040204#NT-S" type="simple" show="new" actuate="onRequest">nonterminal production S</xspecref>defined in section 2.3<bibref ref="XML"/>), that represents the<termref def="dt-schema">schemas</termref>against which validation should occur, i.e. the current schema. The types of schemas referenced in this list must match the type specified with<code>schema-type</code>, otherwise the behavior of an implementation is undefined.</p><p>The schemas specified using this property take precedence to the schema information specified in the document itself. For namespace aware schema, if a schema specified using this property and a schema specified in the document instance (i.e. using the<code>schemaLocation</code>attribute) in a schema document (i.e. using schema<code>import</code>mechanisms) share the same<code>targetNamespace</code>, the schema specified by the user using this property will be used. If two schemas specified using this property share the same<code>targetNamespace</code>or have no namespace, the behavior is implementation dependent.</p><p>If no location has been provided, this parameter is<code>null</code>.</p><note><p>The<code>"schema-location"</code>parameter is ignored unless the "<termref def="parameter-schema-type">schema-type</termref>" parameter value is set. It is strongly recommended that<code>Document.documentURI</code>will be set so that an implementation can successfully resolve any external entities referenced.</p></note></def></gitem><gitem><label id="parameter-schema-type"><code>"schema-type"</code></label><def><p>[<emph>optional</emph>]</p><p>Represent a<code>DOMString</code>object containing an absolute URI and representing the type of the<termref def="dt-schema">schema</termref>language used to validate a document against. Note that no lexical checking is done on the absolute URI.</p><p>If this parameter is not set, a default value may be provided by the implementation, based on the schema languages supported and on the schema language used at load time. If no value is provided, this parameter is<code>null</code>.</p><note><p>For XML Schema<bibref ref="XMLSchema1"/>, applications must use the value<code>"http://www.w3.org/2001/XMLSchema"</code>. For XML DTD<bibref ref="XML"/>, applications must use the value<code>"http://www.w3.org/TR/REC-xml"</code>. Other schema languages are outside the scope of the W3C and therefore should recommend an absolute URI in order to use this method.</p></note></def></gitem><gitem><label id="parameter-split-cdata-sections"><code>"split-cdata-sections"</code></label><def><glist><gitem><label><code>true</code></label><def><p>[<emph>required</emph>] (<emph>default</emph>)</p><p>Split CDATA sections containing the CDATA section termination marker ']]&gt;'. When a CDATA section is split a warning is issued with a<code>DOMError.type</code>equals to<code>"cdata-sections-splitted"</code>and<code>DOMError.relatedData</code>equals to the first<code>CDATASection</code>node in document order resulting from the split.</p></def></gitem><gitem><label><code>false</code></label><def><p>[<emph>required</emph>]</p><p>Signal an error if a<code>CDATASection</code>contains an unrepresentable character.</p></def></gitem></glist></def></gitem><gitem><label id="parameter-validate"><code>"validate"</code></label><def><glist><gitem><label><code>true</code></label><def><p>[<emph>optional</emph>]</p><p>Require the validation against a<termref def="dt-schema">schema</termref>(i.e. XML schema, DTD, any other type or representation of schema) of the document as it is being normalized as defined by<bibref ref="XML"/>. If validation errors are found, or no schema was found, the error handler is notified. Schema-normalized values will not be exposed according to the schema in used unless the parameter "<termref def="parameter-datatype-normalization">datatype-normalization</termref>" is<code>true</code>.</p><p>This parameter will reevaluate:</p><ulist><item><p>Attribute nodes with<code>Attr.specified</code>equals to<code>false</code>, as specified in the description of the<code>Attr</code>interface;</p></item><item><p>The value of the attribute<code>Text.isElementContentWhitespace</code>for all<code>Text</code>nodes;</p></item><item><p>The value of the attribute<code>Attr.isId</code>for all<code>Attr</code>nodes;</p></item><item><p>The attributes<code>Element.schemaTypeInfo</code>and<code>Attr.schemaTypeInfo</code>.</p></item></ulist><note><p>"<termref def="parameter-validate-if-schema">validate-if-schema</termref>" and "validate" are mutually exclusive, setting one of them to<code>true</code>will set the other one to<code>false</code>. Applications should also consider setting the parameter "<termref def="parameter-well-formed">well-formed</termref>" to<code>true</code>, which is the default for that option, when validating the document.</p></note></def></gitem><gitem><label><code>false</code></label><def><p>[<emph>required</emph>] (<emph>default</emph>)</p><p>Do not accomplish schema processing, including the internal subset processing. Default attribute values information are kept. Note that validation might still happen if "<termref def="parameter-validate-if-schema">validate-if-schema</termref>" is<code>true</code>.</p></def></gitem></glist></def></gitem><gitem><label id="parameter-validate-if-schema"><code>"validate-if-schema"</code></label><def><glist><gitem><label><code>true</code></label><def><p>[<emph>optional</emph>]</p><p>Enable validation only if a declaration for the document element can be found in a<termref def="dt-schema">schema</termref>(independently of where it is found, i.e. XML schema, DTD, or any other type or representation of schema). If validation is enabled, this parameter has the same behavior as the parameter "<termref def="parameter-validate">validate</termref>" set to<code>true</code>.</p><note><p>"validate-if-schema" and "<termref def="parameter-validate">validate</termref>" are mutually exclusive, setting one of them to<code>true</code>will set the other one to<code>false</code>.</p></note></def></gitem><gitem><label><code>false</code></label><def><p>[<emph>required</emph>] (<emph>default</emph>)</p><p>No schema processing should be performed if the document has a schema, including internal subset processing. Default attribute values information are kept. Note that validation must still happen if "<termref def="parameter-validate">validate</termref>" is<code>true</code>.</p></def></gitem></glist></def></gitem><gitem><label id="parameter-well-formed"><code>"well-formed"</code></label><def><glist><gitem><label><code>true</code></label><def><p>[<emph>required</emph>] (<emph>default</emph>)</p><p>Check if all nodes are XML<termref def="dt-well-formed">well formed</termref>according to the XML version in use in<code>Document.xmlVersion</code>:</p><ulist><item><p>check if the attribute<code>Node.nodeName</code>contains invalid characters according to its node type and generate a<code>DOMError</code>of type<code>"wf-invalid-character-in-node-name"</code>, with a<code>DOMError.SEVERITY_ERROR</code>severity, if necessary;</p></item><item><p>check if the text content inside<code>Attr</code>,<code>Element</code>,<code>Comment</code>,<code>Text</code>,<code>CDATASection</code>nodes for invalid characters and generate a<code>DOMError</code>of type<code>"wf-invalid-character"</code>, with a<code>DOMError.SEVERITY_ERROR</code>severity, if necessary;</p></item><item><p>check if the data inside<code>ProcessingInstruction</code>nodes for invalid characters and generate a<code>DOMError</code>of type<code>"wf-invalid-character"</code>, with a<code>DOMError.SEVERITY_ERROR</code>severity, if necessary;</p></item></ulist></def></gitem><gitem><label><code>false</code></label><def><p>[<emph>optional</emph>]</p><p>Do not check for XML well-formedness.</p></def></gitem></glist></def></gitem></glist><p>The resolution of the system identifiers associated with entities is done using<code>Document.documentURI</code>. However, when the feature "LS" defined in<bibref role="informative" ref="DOMLS"/>is supported by the DOM implementation, the parameter "resource-resolver" can also be used on<code>DOMConfiguration</code>objects attached to<code>Document</code>nodes. If this parameter is set,<code>Document.normalizeDocument()</code>will invoke the resource resolver instead of using<code>Document.documentURI</code>.</p></descr><method name="setParameter" id="DOMConfiguration-property"><descr><p>Set the value of a parameter.</p></descr><parameters><param name="name" type="DOMString" attr="in"><descr><p>The name of the parameter to set.</p></descr></param><param name="value" type="DOMUserData" attr="in"><descr><p>The new value or<code>null</code>if the user wishes to unset the parameter. While the type of the value parameter is defined as<code>DOMUserData</code>, the object type must match the type defined by the definition of the parameter. For example, if the parameter is<termref def="parameter-error-handler">"error-handler"</termref>, the value must be of type<code>DOMErrorHandler</code>.</p></descr></param></parameters><returns type="void"><descr></descr></returns><raises><exception name="DOMException"><descr><p>NOT_FOUND_ERR: Raised when the parameter name is not recognized.</p><p>NOT_SUPPORTED_ERR: Raised when the parameter name is recognized but the requested value cannot be set.</p><p>TYPE_MISMATCH_ERR: Raised if the value type for this parameter name is incompatible with the expected value type.</p></descr></exception></raises></method><method name="getParameter" id="DOMConfiguration-getParameter"><descr><p>Return the value of a parameter if known.</p></descr><parameters><param name="name" type="DOMString" attr="in"><descr><p>The name of the parameter.</p></descr></param></parameters><returns type="DOMUserData"><descr><p>The current object associated with the specified parameter or<code>null</code>if no object has been associated or if the parameter is not supported.</p></descr></returns><raises><exception name="DOMException"><descr><p>NOT_FOUND_ERR: Raised when the parameter name is not recognized.</p></descr></exception></raises></method><method name="canSetParameter" id="DOMConfiguration-canSetParameter"><descr><p>Check if setting a parameter to a specific value is supported.</p></descr><parameters><param name="name" type="DOMString" attr="in"><descr><p>The name of the parameter to check.</p></descr></param><param name="value" type="DOMUserData" attr="in"><descr><p>An object. if<code>null</code>, the returned value is<code>true</code>.</p></descr></param></parameters><returns type="boolean"><descr><p><code>true</code>if the parameter could be successfully set to the specified value, or<code>false</code>if the parameter is not recognized or the requested value is not supported. This does not change the current value of the parameter itself.</p></descr></returns><raises></raises></method><attribute name="parameterNames" type="DOMStringList" readonly="yes" id="DOMConfiguration-parameterNames"><descr><p>The list of the parameters supported by this<code>DOMConfiguration</code>object and for which at least one value can be set by the application. Note that this list can also contain parameter names defined outside this specification.</p></descr></attribute></interface>
  <interface name="CDATASection" inherits="Text" id="ID-667469212"><descr><p>CDATA sections are used to escape blocks of text containing characters that would otherwise be regarded as markup. The only delimiter that is recognized in a CDATA section is the "]]&gt;" string that ends the CDATA section. CDATA sections cannot be nested. Their primary purpose is for including material such as XML fragments, without needing to escape all the delimiters.</p><p>The<code>CharacterData.data</code>attribute holds the text that is contained by the CDATA section. Note that this<emph>may</emph>contain characters that need to be escaped outside of CDATA sections and that, depending on the character encoding ("charset") chosen for serialization, it may be impossible to write out some characters as part of a CDATA section.</p><p>The<code>CDATASection</code>interface inherits from the<code>CharacterData</code>interface through the<code>Text</code>interface. Adjacent<code>CDATASection</code>nodes are not merged by use of the<code>normalize</code>method of the<code>Node</code>interface.</p><p>No lexical check is done on the content of a CDATA section and it is therefore possible to have the character sequence<code>"]]&gt;"</code>in the content, which is illegal in a CDATA section per section 2.7 of<bibref ref="XML"/>. The presence of this character sequence must generate a fatal error during serialization or the cdata section must be splitted before the serialization (see also the parameter<code>"split-cdata-sections"</code>in the<code>DOMConfiguration</code>interface).</p><note><p>Because no markup is recognized within a<code>CDATASection</code>, character numeric references cannot be used as an escape mechanism when serializing. Therefore, action needs to be taken when serializing a<code>CDATASection</code>with a character encoding where some of the contained characters cannot be represented. Failure to do so would not produce well-formed XML.</p><p>One potential solution in the serialization process is to end the CDATA section before the character, output the character using a character reference or entity reference, and open a new CDATA section for any further characters in the text node. Note, however, that some code conversion libraries at the time of writing do not return an error or exception when a character is missing from the encoding, making the task of ensuring that data is not corrupted on serialization more difficult.</p></note></descr></interface>
  <interface name="DocumentType" inherits="Node" id="ID-412266927"><descr><p>Each<code>Document</code>has a<code>doctype</code>attribute whose value is either<code>null</code>or a<code>DocumentType</code>object. The<code>DocumentType</code>interface in the DOM Core provides an interface to the list of entities that are defined for the document, and little else because the effect of namespaces and the various XML schema efforts on DTD representation are not clearly understood as of this writing.</p><p>DOM Level 3 doesn't support editing<code>DocumentType</code>nodes.<code>DocumentType</code>nodes are<termref def="dt-readonly-node">read-only</termref>.</p></descr><attribute readonly="yes" name="name" type="DOMString" id="ID-1844763134"><descr><p>The name of DTD; i.e., the name immediately following the<code>DOCTYPE</code>keyword.</p></descr></attribute><attribute readonly="yes" name="entities" type="NamedNodeMap" id="ID-1788794630"><descr><p>A<code>NamedNodeMap</code>containing the general entities, both external and internal, declared in the DTD. Parameter entities are not contained. Duplicates are discarded. For example in:<eg role="code" space="preserve">&lt;!DOCTYPE ex SYSTEM "ex.dtd" [ &lt;!ENTITY foo "foo"&gt; &lt;!ENTITY bar "bar"&gt; &lt;!ENTITY bar "bar2"&gt; &lt;!ENTITY % baz "baz"&gt; ]&gt; &lt;ex/&gt;</eg>the interface provides access to<code>foo</code>and the first declaration of<code>bar</code>but not the second declaration of<code>bar</code>or<code>baz</code>. Every node in this map also implements the<code>Entity</code>interface.</p><p>The DOM Level 2 does not support editing entities, therefore<code>entities</code>cannot be altered in any way.</p></descr></attribute><attribute readonly="yes" name="notations" type="NamedNodeMap" id="ID-D46829EF"><descr><p>A<code>NamedNodeMap</code>containing the notations declared in the DTD. Duplicates are discarded. Every node in this map also implements the<code>Notation</code>interface.</p><p>The DOM Level 2 does not support editing notations, therefore<code>notations</code>cannot be altered in any way.</p></descr></attribute><attribute readonly="yes" name="publicId" type="DOMString" id="ID-Core-DocType-publicId" since="DOM Level 2"><descr><p>The public identifier of the external subset.</p></descr></attribute><attribute readonly="yes" name="systemId" type="DOMString" id="ID-Core-DocType-systemId" since="DOM Level 2"><descr><p>The system identifier of the external subset. This may be an absolute URI or not.</p></descr></attribute><attribute readonly="yes" name="internalSubset" type="DOMString" id="ID-Core-DocType-internalSubset" since="DOM Level 2"><descr><p>The internal subset as a string, or<code>null</code>if there is none. This is does not contain the delimiting square brackets.</p><note><p>The actual content returned depends on how much information is available to the implementation. This may vary depending on various parameters, including the XML processor used to build the document.</p></note></descr></attribute></interface>
  <interface name="Notation" inherits="Node" id="ID-5431D1B9"><descr><p>This interface represents a notation declared in the DTD. A notation either declares, by name, the format of an unparsed entity (see<xspecref href="http://www.w3.org/TR/2004/REC-xml-20040204#Notations" type="simple" show="new" actuate="onRequest">section 4.7</xspecref>of the XML 1.0 specification<bibref ref="XML"/>), or is used for formal declaration of processing instruction targets (see<xspecref href="http://www.w3.org/TR/2004/REC-xml-20040204#sec-pi" type="simple" show="new" actuate="onRequest">section 2.6</xspecref>of the XML 1.0 specification<bibref ref="XML"/>). The<code>nodeName</code>attribute inherited from<code>Node</code>is set to the declared name of the notation.</p><p>The DOM Core does not support editing<code>Notation</code>nodes; they are therefore<termref def="dt-readonly-node">readonly</termref>.</p><p>A<code>Notation</code>node does not have any parent.</p></descr><attribute readonly="yes" name="publicId" type="DOMString" id="ID-54F2B4D0"><descr><p>The public identifier of this notation. If the public identifier was not specified, this is<code>null</code>.</p></descr></attribute><attribute readonly="yes" name="systemId" type="DOMString" id="ID-E8AAB1D0"><descr><p>The system identifier of this notation. If the system identifier was not specified, this is<code>null</code>. This may be an absolute URI or not.</p></descr></attribute></interface>
  <interface name="Entity" inherits="Node" id="ID-527DCFF2"><descr><p>This interface represents a known entity, either parsed or unparsed, in an XML document. Note that this models the entity itself<emph>not</emph>the entity declaration.</p><p>The<code>nodeName</code>attribute that is inherited from<code>Node</code>contains the name of the entity.</p><p>An XML processor may choose to completely expand entities before the structure model is passed to the DOM; in this case there will be no<code>EntityReference</code>nodes in the document tree.</p><p>XML does not mandate that a non-validating XML processor read and process entity declarations made in the external subset or declared in parameter entities. This means that parsed entities declared in the external subset need not be expanded by some classes of applications, and that the replacement text of the entity may not be available. When the<xspecref href="http://www.w3.org/TR/2004/REC-xml-20040204#intern-replacement" type="simple" show="new" actuate="onRequest">replacement text</xspecref>is available, the corresponding<code>Entity</code>node's child list represents the structure of that replacement value. Otherwise, the child list is empty.</p><p>DOM Level 3 does not support editing<code>Entity</code>nodes; if a user wants to make changes to the contents of an<code>Entity</code>, every related<code>EntityReference</code>node has to be replaced in the structure model by a clone of the<code>Entity</code>'s contents, and then the desired changes must be made to each of those clones instead.<code>Entity</code>nodes and all their<termref def="dt-descendant">descendants</termref>are<termref def="dt-readonly-node">readonly</termref>.</p><p>An<code>Entity</code>node does not have any parent.</p><note><p>If the entity contains an unbound<termref def="dt-namespaceprefix">namespace prefix</termref>, the<code>namespaceURI</code>of the corresponding node in the<code>Entity</code>node subtree is<code>null</code>. The same is true for<code>EntityReference</code>nodes that refer to this entity, when they are created using the<code>createEntityReference</code>method of the<code>Document</code>interface.</p></note></descr><attribute readonly="yes" name="publicId" type="DOMString" id="ID-D7303025"><descr><p>The public identifier associated with the entity if specified, and<code>null</code>otherwise.</p></descr></attribute><attribute readonly="yes" name="systemId" type="DOMString" id="ID-D7C29F3E"><descr><p>The system identifier associated with the entity if specified, and<code>null</code>otherwise. This may be an absolute URI or not.</p></descr></attribute><attribute readonly="yes" name="notationName" type="DOMString" id="ID-6ABAEB38"><descr><p>For unparsed entities, the name of the notation for the entity. For parsed entities, this is<code>null</code>.</p></descr></attribute><attribute readonly="yes" type="DOMString" name="inputEncoding" id="Entity3-inputEncoding" since="DOM Level 3"><descr><p>An attribute specifying the encoding used for this entity at the time of parsing, when it is an external parsed entity. This is<code>null</code>if it an entity from the internal subset or if it is not known.</p></descr></attribute><attribute readonly="yes" type="DOMString" name="xmlEncoding" id="Entity3-encoding" since="DOM Level 3"><descr><p>An attribute specifying, as part of the text declaration, the encoding of this entity, when it is an external parsed entity. This is<code>null</code>otherwise.</p></descr></attribute><attribute readonly="yes" type="DOMString" name="xmlVersion" id="Entity3-version" since="DOM Level 3"><descr><p>An attribute specifying, as part of the text declaration, the version number of this entity, when it is an external parsed entity. This is<code>null</code>otherwise.</p></descr></attribute></interface>
  <interface name="EntityReference" inherits="Node" id="ID-11C98490"><descr><p><code>EntityReference</code>nodes may be used to represent an entity reference in the tree. Note that character references and references to predefined entities are considered to be expanded by the HTML or XML processor so that characters are represented by their Unicode equivalent rather than by an entity reference. Moreover, the XML processor may completely expand references to entities while building the<code>Document</code>, instead of providing<code>EntityReference</code>nodes. If it does provide such nodes, then for an<code>EntityReference</code>node that represents a reference to a known entity an<code>Entity</code>exists, and the subtree of the<code>EntityReference</code>node is a copy of the<code>Entity</code>node subtree. However, the latter may not be true when an entity contains an unbound<termref def="dt-namespaceprefix">namespace prefix</termref>. In such a case, because the namespace prefix resolution depends on where the entity reference is, the<termref def="dt-descendant">descendants</termref>of the<code>EntityReference</code>node may be bound to different<termref def="dt-namespaceURI">namespace URIs</termref>. When an<code>EntityReference</code>node represents a reference to an unknown entity, the node has no children and its replacement value, when used by<code>Attr.value</code>for example, is empty.</p><p>As for<code>Entity</code>nodes,<code>EntityReference</code>nodes and all their<termref def="dt-descendant">descendants</termref>are<termref def="dt-readonly-node">readonly</termref>.</p><note><p><code>EntityReference</code>nodes may cause element content and attribute value normalization problems when, such as in XML 1.0 and XML Schema, the normalization is performed after entity reference are expanded.</p></note></descr></interface>
  <interface name="ProcessingInstruction" inherits="Node" id="ID-1004215813"><descr><p>The<code>ProcessingInstruction</code>interface represents a "processing instruction", used in XML as a way to keep processor-specific information in the text of the document.</p><p>No lexical check is done on the content of a processing instruction and it is therefore possible to have the character sequence<code>"?&gt;"</code>in the content, which is illegal a processing instruction per section 2.6 of<bibref ref="XML"/>. The presence of this character sequence must generate a fatal error during serialization.</p></descr><attribute readonly="yes" type="DOMString" name="target" id="ID-1478689192"><descr><p>The target of this processing instruction. XML defines this as being the first<termref def="dt-token">token</termref>following the markup that begins the processing instruction.</p></descr></attribute><attribute type="DOMString" name="data" id="ID-837822393" readonly="no"><descr><p>The content of this processing instruction. This is from the first non white space character after the target to the character immediately preceding the<code>?&gt;</code>.</p></descr><setraises><exception name="DOMException"><descr><p>NO_MODIFICATION_ALLOWED_ERR: Raised when the node is readonly.</p></descr></exception></setraises></attribute></interface>
  <interface id="i18n-methods-StringExtend" name="StringExtend"><descr><p>Extensions to a language's native String class or interface</p></descr><method id="i18n-methods-StringExtend-findOffset16" name="findOffset16"><descr><p>Returns the UTF-16 offset that corresponds to a UTF-32 offset. Used for random access.</p><note><p>You can always round-trip from a UTF-32 offset to a UTF-16 offset and back. You can round-trip from a UTF-16 offset to a UTF-32 offset and back if and only if the offset16 is not in the middle of a surrogate pair. Unmatched surrogates count as a single UTF-16 value.</p></note></descr><parameters><param name="offset32" type="int" attr="in"><descr><p>UTF-32 offset.</p></descr></param></parameters><returns type="int"><descr><p>UTF-16 offset</p></descr></returns><raises><exception name="StringIndexOutOfBoundsException"><descr><p>if<code>offset32</code>is out of bounds.</p></descr></exception></raises></method><method id="i18n-methods-StringExtend-findOffset32" name="findOffset32"><descr><p>Returns the UTF-32 offset corresponding to a UTF-16 offset. Used for random access. To find the UTF-32 length of a string, use:<eg space="preserve">len32 = findOffset32(source, source.length());</eg></p><note><p>If the UTF-16 offset is into the middle of a surrogate pair, then the UTF-32 offset of the<emph>end</emph>of the pair is returned; that is, the index of the char after the end of the pair. You can always round-trip from a UTF-32 offset to a UTF-16 offset and back. You can round-trip from a UTF-16 offset to a UTF-32 offset and back if and only if the offset16 is not in the middle of a surrogate pair. Unmatched surrogates count as a single UTF-16 value.</p></note></descr><parameters><param attr="in" type="int" name="offset16"><descr><p>UTF-16 offset</p></descr></param></parameters><returns type="int"><descr><p>UTF-32 offset</p></descr></returns><raises><exception name="StringIndexOutOfBoundsException"><descr><p>if offset16 is out of bounds.</p></descr></exception></raises></method></interface>
</library>
